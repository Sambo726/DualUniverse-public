{"slots":{"0":{"name":"core","type":{"events":[],"methods":[]}},"1":{"name":"teledown","type":{"events":[],"methods":[]}},"2":{"name":"slot3","type":{"events":[],"methods":[]}},"3":{"name":"slot4","type":{"events":[],"methods":[]}},"4":{"name":"slot5","type":{"events":[],"methods":[]}},"5":{"name":"slot6","type":{"events":[],"methods":[]}},"6":{"name":"slot7","type":{"events":[],"methods":[]}},"7":{"name":"slot8","type":{"events":[],"methods":[]}},"8":{"name":"slot9","type":{"events":[],"methods":[]}},"9":{"name":"slot10","type":{"events":[],"methods":[]}},"-1":{"name":"unit","type":{"events":[],"methods":[]}},"-2":{"name":"system","type":{"events":[],"methods":[]}},"-3":{"name":"library","type":{"events":[],"methods":[]}}},"handlers":[{"code":"core.hide()\nNav.control.switchOffHeadlights()\n","filter":{"args":[],"signature":"stop()","slotKey":"-1"},"key":"0"},{"code":"--[[\nAuthor: Ater Omen\nhttps://github.com/rhoffsch42/DualUniverse-public\nWORK IN PROGRESS\n12 Oct 2020\n\nA basic pet following you.\nIf you dig and mine,it will stay on top of you at the surface\nto have the closest distance for the linked container.\nIt will have a HUD to facilitate mining.\n\nRequirements:\n\t- 1 telemeter pointing down, put it underneath the ship\n\t- 1 remote control\n\t- you must disable thrust along gravity on your hovers and vertical boosters\n\t- download and put svghelper.lua in this fodler: Dual Universe\\Game\\data\\lua\n\t  You can find it here: https://github.com/rhoffsch42/DualUniverse-public\n\nInstallation:\n\t- inject the conf in the remote control\n\t- link the core\n\t- link the telemeter\nAll settings are in unit > start. Tweak them to match your ship capabilities.\n\nCommands:\n\t- option 1 : toggle debug panel\n\n]]\n\nNav = Navigator.new(system, core, unit)\nNav.axisCommandManager:setupCustomTargetSpeedRanges(axisCommandId.longitudinal, {100, 500, 1000, 5000})\nNav.axisCommandManager:setTargetGroundAltitude(6)\n\n-- element widgets\n-- For now we have to alternate between PVP and non-PVP widgets to have them on the same side.\ncore.show()\n\n-- freeze the player in he is remote controlling the construct\nif Nav.control.isRemoteControlled() == 1 then\n    system.freeze(0)\nend\n\n-- landing gear\n-- make sure every gears are synchonized with the first\ngearExtended = (Nav.control.isAnyLandingGearExtended() == 1) -- make sure it's a lua boolean\nif gearExtended then\n    Nav.control.extendLandingGears()\nelse\n    Nav.control.retractLandingGears()\nend\n\n--------------------------------------\n-- start mining pet\nsvg = require \"svghelper\"\nassert(svg, \"error loading svghelper.lua\")\nsvg._textColor = \"#b9babb\"\nsvg._rectColor = \"#121326\"\n\ndeg2rad    = math.pi/180\nrad2deg    = 180/math.pi\n\ng_data = {}\ng_data.telemeter = {}\ng_data.telemeter.maxDistance = teledown.getMaxDistance()\ng_data.telemeter.down = 0\ng_data.diplayDebug = true\n\ng_data.player = {}\ng_data.player.id = unit.getMasterPlayerId()\ng_data.player.name = system.getPlayerName(g_data.player.id)\n\ng_data.construct = {}\ng_data.construct.orientation = {}\ng_data.construct.surfaceDistance = 0\ng_data.construct.trajectoryAngle = 0\ng_data.construct.velocity = 0\n\ng_pet = {}\ng_pet.settings = {}\ng_pet.settings.heelRange = 30 --meters\ng_pet.settings.travelGroundAltitude = 50 --meters \ng_pet.settings.minTravelGroundAltitude = 5 --metters, dont put it too high or the pet wont move\ng_pet.settings.rollTolerance = 3 --degree\ng_pet.settings.pitchTolerance = 3 --degree\ng_pet.settings.yawTolerance = 10 --degree\ng_pet.settings.travelPitchAngle = 10 --degree\ng_pet.settings.trajectoryAngleTolerance = g_pet.settings.yawTolerance * 2 --degree\ng_pet.settings.maxSpeed = 13 --m/s\n\ng_pet.status = {}\ng_pet.status.sitting = 0\ng_pet.status.landing = 1\ng_pet.status.takeoff = 2\ng_pet.status.travel = 3\ng_pet.status.current = g_pet.status.sitting\n\ng_pet.braking = 0\n\nsystem.showScreen(1)\nunit.setTimer(\"pet\", 0.1)\nunit.setTimer(\"hud\", 0.1)","filter":{"args":[],"signature":"start()","slotKey":"-1"},"key":"1"},{"code":"g_data.vertical = vec3(core.getWorldVertical())\ng_data.telemeter.down = teledown.getDistance()\n\ng_data.construct.mass = core.getConstructMass()\ng_data.construct.pos = vec3(core.getConstructWorldPos())\ng_data.construct.alt = core.getAltitude()\nlocal velocityVec = vec3(core.getWorldVelocity())\ng_data.construct.velocity = velocityVec:len()\ng_data.construct.right = vec3(core.getConstructWorldOrientationRight())\ng_data.construct.forward = vec3(core.getConstructWorldOrientationForward())\n\nlocal relativePos = vec3(unit.getMasterPlayerRelativePosition())\nlocal surfaceRelativePos = relativePos:project_on_plane(g_data.vertical)\ng_data.construct.distance = relativePos:len()\ng_data.construct.surfaceDistance = surfaceRelativePos:len()\ng_data.player.pos = relativePos + g_data.construct.pos\n\nlocal surfaceVelocityVec = velocityVec:project_on_plane(g_data.vertical)\ng_data.construct.trajectoryAngle = rad2deg * surfaceVelocityVec:angle_between(surfaceRelativePos)\n-- roll\ng_data.construct.orientation.roll = 90 - rad2deg * g_data.construct.right:angle_between(g_data.vertical)\n\n-- pitch\nlocal pitchTarget = 90 - (g_pet.status.current == g_pet.status.travel and g_pet.settings.travelPitchAngle or 0)\ng_data.construct.orientation.pitch = -1 * (pitchTarget - rad2deg * g_data.construct.forward:angle_between(g_data.vertical))\n--inverted to match pitchInput \n\n-- yaw\nlocal yawOnFloor = rad2deg * g_data.construct.forward:project_on_plane(g_data.vertical)\nlocal relativeOnFloor = relativePos:project_on_plane(g_data.vertical)\ng_data.construct.orientation.yawOnPlayer = rad2deg * yawOnFloor:angle_between(relativeOnFloor)\nlocal rightOnFloor = g_data.construct.right:project_on_plane(g_data.vertical)\nlocal dotrp = rightOnFloor:dot(relativeOnFloor)\nif (dotrp < 0) then\n    g_data.construct.orientation.yawOnPlayer = -g_data.construct.orientation.yawOnPlayer\nend\n\n","filter":{"args":[{"value":"pet"}],"signature":"tick(timerId)","slotKey":"-1"},"key":"2"},{"code":"local status = {\"sitting\", \"landing\", \"takeoff\", \"travel\"}\n\nif (g_data.diplayDebug) then\n    local displayConstruct = false\n    local width = displayConstruct and 800 or 400\n    svg.body = [[<g><rect x=\"0\" y=\"0\" width=\"]]..width..[[\" height=\"1080\" fill=\"]].. svg._rectColor ..[[\" fill-opacity=\"0.85\"></rect>]]\n    svg.body = svg.body .. svg.toSVG({status[g_pet.status.current+1]}, 3, 1050, {displayKey = false, displayTable = true})\n    svg.body = svg.body .. svg.toSVG(g_pet, 50, 40, {displayKey = true, displayTable = true})\n    if (displayConstruct) then\n        svg.body = svg.body .. svg.toSVG(g_data, 500, 40, {displayKey = true, displayTable = true})\n    end\n    \n    svg.body = svg.body .. \"</g>\"\n\n    system.setScreen(svg.dump())\nelse\n    svg.body = [[<g><rect x=\"0\" y=\"1055\" width=\"75\" height=\"25\" fill=\"]].. svg._rectColor ..[[\" fill-opacity=\"0.85\"></rect>]]\n    svg.body = svg.body .. svg.toSVG({status[g_pet.status.current+1]}, 3, 1050, {displayKey = false, displayTable = true})\n    svg.body = svg.body .. \"</g>\"\n    \n    system.setScreen(svg.dump())\nend\n","filter":{"args":[{"value":"hud"}],"signature":"tick(timerId)","slotKey":"-1"},"key":"3"},{"code":"pitchInput = 0\npitchInputFromDevice = 0\nrollInput = 0\nyawInput = 0\nverticalStrafeInput = 0\nlateralStrafeInput = 0\nbrakeInput = 0\n","filter":{"args":[],"signature":"start()","slotKey":"-2"},"key":"4"},{"code":"-- constants: use 'myvar = defaultValue --export: description' to expose the variable in context menu<br>in degree<br>Valid values: Superior or equal to 1\nlocal rollAmplitude = 10 --export: When turning, the auto roll won't go over or under rollAmplitude<br>in degree<br>Valid values: Superior or equal to 1\nlocal pitchAmplitude = g_pet.settings.travelPitchAngle --export: When pitching, the pitch won't go over or under pitchAmplitude (in degree)\nlocal yawSpeedFactor = 0.5 --export When turning, the inputs will be multiplied by this factor<br>Valid values: Superior or equal to 0.01\nlocal yawAccelerationFactor = 3 --export: When turning, the yaw response will be multiplied by this factor<br>Valid values: Superior or equal to 0.01\n\nlocal lateralAntiDriftFactor = 1 --export: When compensating for drift, this factor will increase/decrease the drift force requested to engines<br>Valid values: Superior or equal to 0.01\nlocal lateralStrafeFactor = 5 --export: This factor will increase/decrease the player input along the horizontal strafe axis axis<br>Valid values: Superior or equal to 0.01\n\nlocal brakeSpeedFactor = 1 --export: When braking, this factor will increase the brake force by brakeSpeedFactor * velocity<br>Valid values: Superior or equal to 0.01\nlocal brakeFlatFactor = 4 --export: When braking, this factor will increase the brake force by a flat brakeFlatFactor * velocity direction><br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01\nlocal autoBrakeSpeed = 15 --export: Auto brake when speed is below that value (in m/s), with no thrust\n\n-- validate params\nbrakeSpeedFactor = math.max(brakeSpeedFactor, 0.01)\nbrakeFlatFactor = math.max(brakeFlatFactor, 0.01)\nrollAmplitude = math.max(rollAmplitude, 1)\npitchAmplitude = math.max(pitchAmplitude, 1)\nyawSpeedFactor = math.max(yawSpeedFactor, 0.01)\nyawAccelerationFactor =  math.max(yawAccelerationFactor, 0.01)\n\nif (rollPID == nil) then\n    rollPID = pid.new(0.2, 0, 10)\n    pitchPID = pid.new(0.2, 0, 10)\nend\n\n-- final inputs\nif Nav.control.isMouseDirectControlActivated() then\n    -- in direct control, we tweak the pitch to behave inbetween virtual joystick and direct control\n    -- this helps a lot for ground construct control\n    pitchInputFromDevice = utils.clamp(pitchInputFromDevice + system.getControlDeviceForwardInput() * system.getActionUpdateDeltaTime(), -1.0, 1.0)\nelse\n    pitchInputFromDevice = system.getControlDeviceForwardInput()\nend\nlocal finalPitchInput = pitchInput + pitchInputFromDevice\nlocal finalRollInput = rollInput + system.getControlDeviceYawInput()\nlocal finalYawInput = yawInput - system.getControlDeviceLeftRightInput()\nlocal combinedRollYawInput = utils.clamp(finalRollInput - finalYawInput, -1.0, 1.0);\nlocal finalVerticalStrafeInput = verticalStrafeInput\nlocal finalLateralStrafeInput = lateralStrafeInput;\nlocal finalBrakeInput = brakeInput\n\n-- Axis\nlocal worldVertical = vec3(core.getWorldVertical())\nlocal constructUp = vec3(core.getConstructWorldOrientationUp())\nlocal constructForward = vec3(core.getConstructWorldOrientationForward())\nlocal constructRight = vec3(core.getConstructWorldOrientationRight())\nlocal constructVelocity = vec3(core.getWorldVelocity())\nlocal constructVelocityDir = vec3(core.getWorldVelocity()):normalize()\nlocal constructAngularVelocity = vec3(core.getWorldAngularVelocity())\nlocal constructYawVelocity = constructAngularVelocity:dot(constructUp)\n\n-- Engine commands\nlocal keepCollinearity = 0 -- for easier reading\nlocal dontKeepCollinearity = 1 -- for easier reading\nlocal tolerancePercentToSkipOtherPriorities = 1 -- if we are within this tolerance (in%), we don't go to the next priorities\n\n-- Rotation\nlocal currentRollDeg = getRoll(worldVertical, constructForward, constructRight)\nlocal currentPitchDeg = -math.asin(constructForward:dot(worldVertical)) * constants.rad2deg\nlocal targetRollDeg =  utils.clamp(combinedRollYawInput * rollAmplitude, -rollAmplitude, rollAmplitude)\nlocal targetPitchDeg =  utils.clamp(finalPitchInput * pitchAmplitude, -pitchAmplitude, pitchAmplitude)\nrollPID:inject(targetRollDeg - currentRollDeg)\npitchPID:inject(targetPitchDeg - currentPitchDeg)\n\nlocal constructYawTargetVelocity = -combinedRollYawInput * yawSpeedFactor\nlocal constructYawTargetAcceleration = yawAccelerationFactor * (constructYawTargetVelocity - constructYawVelocity)\n\nlocal constructTargetAngularVelocity = rollPID:get() * constructForward\n                                        + pitchPID:get() * constructRight\n                                        + constructYawTargetAcceleration * constructUp\n\nNav:setEngineTorqueCommand('torque', constructTargetAngularVelocity, keepCollinearity, 'airfoil', '', '', tolerancePercentToSkipOtherPriorities)\n\n-- Brakes\nif (finalBrakeInput == 0 and autoBrakeSpeed > 0 and Nav.axisCommandManager.throttle == 0 and constructVelocity:len() < autoBrakeSpeed) then\n    finalBrakeInput = 1\nend\nlocal brakeAcceleration = -finalBrakeInput * (brakeSpeedFactor * constructVelocity + brakeFlatFactor * constructVelocityDir)\nNav:setEngineForceCommand('brake', brakeAcceleration)\n\n-- AutoNavigation regroups all the axis command by 'TargetSpeed'\nlocal autoNavigationEngineTags = ''\nlocal autoNavigationAcceleration = vec3()\nlocal autoNavigationUseBrake = false\n\n-- Longitudinal Translation\nlocal longitudinalEngineTags = 'thrust analog longitudinal'\nlocal longitudinalCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.longitudinal)\nif (longitudinalCommandType == axisCommandType.byThrottle) then\n    local longitudinalAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromThrottle(longitudinalEngineTags,axisCommandId.longitudinal)\n    Nav:setEngineForceCommand(longitudinalEngineTags, longitudinalAcceleration, keepCollinearity)\nelseif  (longitudinalCommandType == axisCommandType.byTargetSpeed) then\n    local longitudinalAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromTargetSpeed(axisCommandId.longitudinal)\n    autoNavigationEngineTags = autoNavigationEngineTags .. ' , ' .. longitudinalEngineTags\n    autoNavigationAcceleration = autoNavigationAcceleration + longitudinalAcceleration\n    if (Nav.axisCommandManager:getTargetSpeed(axisCommandId.longitudinal) == 0 or -- we want to stop\n        Nav.axisCommandManager:getCurrentToTargetDeltaSpeed(axisCommandId.longitudinal) < - Nav.axisCommandManager:getTargetSpeedCurrentStep(axisCommandId.longitudinal) * 0.5) -- if the longitudinal velocity would need some braking\n    then\n        autoNavigationUseBrake = true\n    end\n\nend\n\n-- Lateral Translation\nlocal lateralStrafeEngineTags = 'thrust analog lateral'\nlocal lateralCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.lateral)\nif (lateralCommandType == axisCommandType.byThrottle) then\n    local lateralStrafeAcceleration =  Nav.axisCommandManager:composeAxisAccelerationFromThrottle(lateralStrafeEngineTags,axisCommandId.lateral)\n    Nav:setEngineForceCommand(lateralStrafeEngineTags, lateralStrafeAcceleration, keepCollinearity)\nelseif  (lateralCommandType == axisCommandType.byTargetSpeed) then\n    local lateralAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromTargetSpeed(axisCommandId.lateral)\n    autoNavigationEngineTags = autoNavigationEngineTags .. ' , ' .. lateralStrafeEngineTags\n    autoNavigationAcceleration = autoNavigationAcceleration + lateralAcceleration\nend\n\n-- Vertical Translation\nlocal verticalStrafeEngineTags = 'thrust analog vertical'\nlocal verticalCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.vertical)\nif (verticalCommandType == axisCommandType.byThrottle) then\n    local verticalStrafeAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromThrottle(verticalStrafeEngineTags,axisCommandId.vertical)\n    Nav:setEngineForceCommand(verticalStrafeEngineTags, verticalStrafeAcceleration, keepCollinearity, 'airfoil', 'ground', '', tolerancePercentToSkipOtherPriorities)\nelseif  (verticalCommandType == axisCommandType.byTargetSpeed) then\n    local verticalAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromTargetSpeed(axisCommandId.vertical)\n    autoNavigationEngineTags = autoNavigationEngineTags .. ' , ' .. verticalStrafeEngineTags\n    autoNavigationAcceleration = autoNavigationAcceleration + verticalAcceleration\nend\n\n-- Auto Navigation (Cruise Control)\nif (autoNavigationAcceleration:len() > constants.epsilon) then\n    if (brakeInput ~= 0 or autoNavigationUseBrake or math.abs(constructVelocityDir:dot(constructForward)) < 0.95)  -- if the velocity is not properly aligned with the forward\n    then\n        autoNavigationEngineTags = autoNavigationEngineTags .. ', brake'\n    end\n    Nav:setEngineForceCommand(autoNavigationEngineTags, autoNavigationAcceleration, dontKeepCollinearity, '', '', '', tolerancePercentToSkipOtherPriorities)\nend\n\n-- Rockets\nNav:setBoosterCommand('rocket_engine')\n","filter":{"args":[],"signature":"flush()","slotKey":"-2"},"key":"5"},{"code":"Nav:update()\n\nlocal function\tstabilize(axis, tolerance)\n    if (axis == nil) then return 0 end\n    return (axis > tolerance) and -1 or ((axis < -tolerance) and 1 or 0)\nend\n\n-- pet status\nlocal inTheAir = g_data.telemeter.down >= g_pet.settings.minTravelGroundAltitude\nlocal isDrifting = g_data.construct.trajectoryAngle > g_pet.settings.trajectoryAngleTolerance\nlocal atHeelRange = g_data.construct.surfaceDistance < g_pet.settings.heelRange\nlocal goingTooFast = g_data.construct.velocity > g_pet.settings.maxSpeed\n\nif not atHeelRange then\n    g_pet.status.current = inTheAir and g_pet.status.travel or g_pet.status.takeoff\nelse\n    g_pet.status.current = inTheAir and g_pet.status.landing or g_pet.status.sitting\nend\n\n\nif inTheAir then\n   -- rollInput = stabilize(g_data.construct.orientation.roll, g_pet.settings.rollTolerance)\n   -- pitchInput = stabilize(g_data.construct.orientation.pitch, g_pet.settings.pitchTolerance)\n    yawInput = stabilize(g_data.construct.orientation.yawOnPlayer, g_pet.settings.yawTolerance)\nelse\n    rollInput = 0\n    pitchInput = 0\n    yawInput = 0\nend\n\n\nif (g_pet.status.current == g_pet.status.landing) then\n    Nav.axisCommandManager:setTargetGroundAltitude(0)\n    brakeInput = 1\n    pitchInput = 0\nelseif (g_pet.status.current == g_pet.status.takeoff) then\n    Nav.axisCommandManager:setTargetGroundAltitude(g_pet.settings.travelGroundAltitude)\n    brakeInput = 1\n    pitchInput = 0\nelseif (g_pet.status.current == g_pet.status.sitting) then\n    -- take a shit\n    brakeInput = 1\n    pitchInput = 0\nelseif (g_pet.status.current == g_pet.status.travel) then\n    -- follow the player on surface\n    brakeInput = isDrifting and 1 or 0\n    pitchInput = -1 -- going forward\nend\n\nif goingTooFast then brakeInput = 1 end\n\n--debug\ng_pet.braking = brakeInput\ng_pet.surfaceDistance = g_data.construct.surfaceDistance\ng_pet.speed = g_data.construct.velocity\n","filter":{"args":[],"signature":"update()","slotKey":"-2"},"key":"6"},{"code":"if Nav.control.isAnyHeadlightSwitchedOn() == 1 then\n    Nav.control.switchOffHeadlights()\nelse\n    Nav.control.switchOnHeadlights()\nend\n","filter":{"args":[{"value":"light"}],"signature":"actionStart(light)","slotKey":"-2"},"key":"7"},{"code":"g_data.diplayDebug = not g_data.diplayDebug\n--system.showScreen(g_data.diplayDebug and 1 or 0)\n","filter":{"args":[{"value":"option1"}],"signature":"actionStart(action)","slotKey":"-2"},"key":"8"}],"methods":[],"events":[]}
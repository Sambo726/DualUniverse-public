# This is a file describing an autoconfiguration "Minimal Piloting", do not edit.
# See custom/sample.conf for a more generic template and explanation on the syntax.
# MPC v1.3

name: Minimal Piloting

slots:
    core:
        class: CoreUnit
    warpdrive:
        class: WarpDriveUnit
    atmofueltank:
        class: AtmoFuelContainer
        select: all
    spacefueltank:
        class: SpaceFuelContainer
        select: all
    radar:
        class: RadarPVPUnit
        select: manual
    telemeter:
        class: TelemeterUnit

handlers:
    unit:
        tick:
            args: [hud]
            lua : |
                mpc:updateTanksPercent()
                mpc:updatePilotingInfos()
                mpc:automaticFeatures()

                svg.body = mpc:getSvgcode()
                system.setScreen(svg.dump())
        tick:
            args: [draw]
            lua : |
                -- draw
                function    svgCircularGauge(percent, pos, r, class, bgclass)
                    pos = vec3(pos)
                    class = class or "gauge"
                    bgclass = bgclass or "gauge-bg"
                    local size = r*2
                    local da = ""
                    if percent ~= 100 then
                        local d = math.ceil(2 * math.pi * r)+1
                        local p = math.ceil(d * percent / 100)
                        da = string.format([[ stroke-dasharray="%d %d"]], p, d)
                    end
                    return string.format([[
                        <circle class="%s" cx="%d" cy="%d" r="%d"/>
                        <rect class="%s" x="%d" y="%d" width="%d" height="%d" rx="%d" ry="%d"%s/>]],
                        bgclass, pos.x, pos.y, r,
                        class, pos.x-r, pos.y-r, size, size, r, r, da)
                --<circle class="%s" cx="%d" cy="%d" r="%d" stroke-dasharray="5 10" />
                end

                function	svgTextBG(text, position, fontsize, color, inverted)--inverted is like an unselected button
                    local pos = position and {x=position.x, y=position.y} or {x=0, y=0}
                    fontsize = fontsize and math.floor(fontsize) or 15
                    color = color or "white"
                    inverted = inverted or false
                    local textcolor = inverted and color or "black"
                    local stroke = inverted and ("stroke-width:1;stroke:" .. color) or ""
                    color = inverted and "none" or color
                    local x = math.floor(pos.x)
                    local y = math.floor(pos.y)
                    local pad = 0.35
                    local textlen = math.floor(fontsize * string.len(text) * 0.6) --depend of the font
                    local xlen = math.floor(fontsize*pad*2) + textlen
                    local ylen = math.floor(fontsize*(1+pad))
                    local round = math.floor(fontsize*0.4)
                    
                    local svgcode = string.format([[
                        <rect x="%d" y="%d" width="%d" height="%d" rx="%d" ry="%d" style="fill:%s;%s" />
                        <text x="%d" y="%d" textLength="%d" font-size="%d" font-weight="bold" fill="%s">%s</text>]],
                        x, y, xlen, ylen, round, round, color, stroke,
                        x + math.floor(fontsize*pad), y + fontsize, textlen, fontsize, textcolor, text)
                    
                    return svgcode
                end

                unit.stopTimer("draw")
        start:
            lua: |
                --[[
                    MPC v1.3

                    optional links (element : slot name) :
                        - lightSwitch : manual switch (with relay(s) to all lights)
                        - vboosterSwitch : manual switch (with relay(s) to all forcefields blocking vboosters)
                    
                    commands (* are optional):
                        option1 : toggle handbrake
                        option2 : toggle brakes
                        *option3 : toggle lights
                        *option4 : toggle vboosters

                    todo:
                        basic interface:
                            fuel tank : time to depletion
                        settings: toggle space brake safety if <2su (dep: BTI)
                --]]

                pitchInput = 0
                rollInput = 0
                yawInput = 0
                brakeInput = 0

                Nav = Navigator.new(system, core, unit)
                Nav.axisCommandManager:setupCustomTargetSpeedRanges(axisCommandId.longitudinal, {1000, 5000, 10000, 20000, 30000})
                Nav.axisCommandManager:setTargetGroundAltitude(4)

                -- element widgets
                -- For now we have to alternate between PVP and non-PVP widgets to have them on the same side.
                --[[
                _autoconf.displayCategoryPanel(weapon, weapon_size, "Weapons", "weapon", true)
                core.show()
                _autoconf.displayCategoryPanel(radar, radar_size, "Periscope", "periscope")
                placeRadar = true
                if atmofueltank_size > 0 then
                    _autoconf.displayCategoryPanel(atmofueltank, atmofueltank_size, "Atmo Fuel", "fuel_container")
                    if placeRadar then
                        _autoconf.displayCategoryPanel(radar, radar_size, "Radar", "radar")
                        placeRadar = false
                    end
                end
                if spacefueltank_size > 0 then
                    _autoconf.displayCategoryPanel(spacefueltank, spacefueltank_size, "Space Fuel", "fuel_container")
                    if placeRadar then
                        _autoconf.displayCategoryPanel(radar, radar_size, "Radar", "radar")
                        placeRadar = false
                    end
                end
                _autoconf.displayCategoryPanel(rocketfueltank, rocketfueltank_size, "Rocket Fuel", "fuel_container")
                if placeRadar then -- We either have only rockets or no fuel tanks at all, uncommon for usual vessels
                    _autoconf.displayCategoryPanel(radar, radar_size, "Radar", "radar")
                    placeRadar = false
                end
                --]]
                if antigrav ~= nil then antigrav.show() end
                if warpdrive ~= nil then warpdrive.show() end
                if gyro ~= nil then gyro.show() end

                -- freeze the player in he is remote controlling the construct
                if Nav.control.isRemoteControlled() == 1 then
                    system.freeze(1)
                end

                -- landing gear
                -- make sure every gears are synchonized with the first
                gearExtended = (Nav.control.isAnyLandingGearExtended() == 1) -- make sure it's a lua boolean
                if gearExtended then
                    Nav.control.extendLandingGears()
                else
                    Nav.control.retractLandingGears()
                end

                ---------
                unit.setTimer("draw", 0.01)
                local atmotanks = {atmofueltank_1,atmofueltank_2,atmofueltank_3,atmofueltank_4,atmofueltank_5,atmofueltank_6,atmofueltank_7,atmofueltank_8,atmofueltank_9,atmofueltank_10,atmofueltank_11,atmofueltank_12,atmofueltank_13,atmofueltank_14,atmofueltank_15,atmofueltank_16,atmofueltank_17,atmofueltank_18,atmofueltank_19,atmofueltank_20,}
                local spacetanks = {spacefueltank_1,spacefueltank_2,spacefueltank_3,spacefueltank_4,spacefueltank_5,spacefueltank_6,spacefueltank_7,spacefueltank_8,spacefueltank_9,spacefueltank_10,spacefueltank_11,spacefueltank_12,spacefueltank_13,spacefueltank_14,spacefueltank_15,spacefueltank_16,spacefueltank_17,spacefueltank_18,spacefueltank_19,spacefueltank_20,}
                --export variables:
                local ContainerOptimization = 5 --export: +5% volume / level
                local FuelTankOptimization = 5 --export: -5% content mass / level
                local AtmosphericFuelTankHandling = 5 --export: +20% fuel tank volume when put down
                local SpaceFuelTankHandling = 5 --export: +20% fuel tank volume when put down
                local gearsThreshold = 40 --export: height in meter where the gears retract or extend
                local spaceBrakePower = 0 --export: your maximum space brake power in kN
                assert(spaceBrakePower ~= 0, "Error: update spaceBrakePower in lua parameters with the ship maximum brake power in kN")
                spaceBrakePower = spaceBrakePower * 1000

                svg = requireSvgHelper() -- or require("svghelper")
                svg.style = svg.style .. [[
                .fuel { fill: none; }
                .nitron { stroke: #3399ff; }
                .kergon { stroke: #ffff4d; }
                .gauge { stroke-width: 6; }
                .gauge-bg { stroke: #bbbbbb; stroke-width: 3; }
                .val { font-size: 20px; text-anchor: middle; fill: #bbbbbb; stroke: #bbbbbb; }
                ]]
                mpc = requireMinimalPilotingConfig(atmotanks, spacetanks)
                mpc:initTanksData(ContainerOptimization, FuelTankOptimization, AtmosphericFuelTankHandling, SpaceFuelTankHandling)
                mpc.gearsThreshold = gearsThreshold
                mpc.brakePower = spaceBrakePower
                mpc.bti = requireBasicTravelInfos()
                if not warpdrive then
                    mpc.uiPos = mpc.uiPos + vec3(0, 170, 0)
                end

                system.showScreen(1)
                unit.setTimer("hud", 0.25)
                if lightSwitch then
                    lightSwitch.activate()
                    mpc.piloting.lights = true
                end
                if vboosterSwitch then
                    vboosterSwitch.deactivate()
                    mpc.piloting.vboosters = true
                end

        stop:
            lua: |
                _autoconf.hideCategoryPanels()
                if antigrav ~= nil then antigrav.hide() end
                if warpdrive ~= nil then warpdrive.hide() end
                if gyro ~= nil then gyro.hide() end
                core.hide()
                Nav.control.switchOffHeadlights()

                ----------
                if lightSwitch then
                    lightSwitch.deactivate()
                    mpc.piloting.lights = false
                end
                if vboosterSwitch then
                    vboosterSwitch.deactivate()
                    mpc.piloting.vboosters = true
                end

    system:
        flush:
            lua: |
                if (not mpc) or (not mpc.piloting) then
                    return
                end

                -- constants: use 'myvar = defaultValue --export: description' to expose the variable in context menu

                local pitchSpeedFactor = 0.8 --notexport: This factor will increase/decrease the player input along the pitch axis<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01
                local yawSpeedFactor =  1 --notexport: This factor will increase/decrease the player input along the yaw axis<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01
                local rollSpeedFactor = 1.5 --notexport: This factor will increase/decrease the player input along the roll axis<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01

                local brakeSpeedFactor = 3 --notexport: When braking, this factor will increase the brake force by brakeSpeedFactor * velocity<br>Valid values: Superior or equal to 0.01
                local brakeFlatFactor = 1 --notexport: When braking, this factor will increase the brake force by a flat brakeFlatFactor * velocity direction><br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01

                local autoRoll = false --export: [Only in atmosphere]<br>When the pilot stops rolling,  flight model will try to get back to horizontal (no roll)
                local autoRollFactor = 2 --notexport: [Only in atmosphere]<br>When autoRoll is engaged, this factor will increase to strength of the roll back to 0<br>Valid values: Superior or equal to 0.01

                local turnAssist = true --export: [Only in atmosphere]<br>When the pilot is rolling, the flight model will try to add yaw and pitch to make the construct turn better<br>The flight model will start by adding more yaw the more horizontal the construct is and more pitch the more vertical it is
                local turnAssistFactor = 2 --notexport: [Only in atmosphere]<br>This factor will increase/decrease the turnAssist effect<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01

                local torqueFactor = 2 -- Force factor applied to reach rotationSpeed<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01

                -- validate params
                pitchSpeedFactor = math.max(pitchSpeedFactor, 0.01)
                yawSpeedFactor = math.max(yawSpeedFactor, 0.01)
                rollSpeedFactor = math.max(rollSpeedFactor, 0.01)
                torqueFactor = math.max(torqueFactor, 0.01)
                brakeSpeedFactor = math.max(brakeSpeedFactor, 0.01)
                brakeFlatFactor = math.max(brakeFlatFactor, 0.01)
                autoRollFactor = math.max(autoRollFactor, 0.01)
                turnAssistFactor = math.max(turnAssistFactor, 0.01)

                -- final inputs
                local finalPitchInput = pitchInput + system.getControlDeviceForwardInput()
                local finalRollInput = rollInput + system.getControlDeviceYawInput()
                local finalYawInput = yawInput - system.getControlDeviceLeftRightInput()
                local finalBrakeInput = brakeInput

                -- Axis
                local worldVertical = vec3(core.getWorldVertical()) -- along gravity
                local constructUp = vec3(core.getConstructWorldOrientationUp())
                local constructForward = vec3(core.getConstructWorldOrientationForward())
                local constructRight = vec3(core.getConstructWorldOrientationRight())
                local constructVelocity = vec3(core.getWorldVelocity())
                local constructVelocityDir = vec3(core.getWorldVelocity()):normalize()
                local currentRollDeg = getRoll(worldVertical, constructForward, constructRight)
                local currentRollDegAbs = math.abs(currentRollDeg)
                local currentRollDegSign = utils.sign(currentRollDeg)

                -- Rotation
                local constructAngularVelocity = vec3(core.getWorldAngularVelocity())
                local targetAngularVelocity = finalPitchInput * pitchSpeedFactor * constructRight
                                                + finalRollInput * rollSpeedFactor * constructForward
                                                + finalYawInput * yawSpeedFactor * constructUp

                -- In atmosphere?
                if worldVertical:len() > 0.01 and unit.getAtmosphereDensity() > 0.0 then
                    local autoRollRollThreshold = 1.0
                    -- autoRoll on AND currentRollDeg is big enough AND player is not rolling
                    if autoRoll == true and currentRollDegAbs > autoRollRollThreshold and finalRollInput == 0 then
                        local targetRollDeg = utils.clamp(0,currentRollDegAbs-30, currentRollDegAbs+30);  -- we go back to 0 within a certain limit
                        if (rollPID == nil) then
                            rollPID = pid.new(autoRollFactor * 0.01, 0, autoRollFactor * 0.1) -- magic number tweaked to have a default factor in the 1-10 range
                        end
                        rollPID:inject(targetRollDeg - currentRollDeg)
                        local autoRollInput = rollPID:get()

                        targetAngularVelocity = targetAngularVelocity + autoRollInput * constructForward
                    end
                    local turnAssistRollThreshold = 20.0
                    -- turnAssist AND currentRollDeg is big enough AND player is not pitching or yawing
                    if turnAssist == true and currentRollDegAbs > turnAssistRollThreshold and finalPitchInput == 0 and finalYawInput == 0 then
                        local rollToPitchFactor = turnAssistFactor * 0.1 -- magic number tweaked to have a default factor in the 1-10 range
                        local rollToYawFactor = turnAssistFactor * 0.025 -- magic number tweaked to have a default factor in the 1-10 range

                        -- rescale (turnAssistRollThreshold -> 180) to (0 -> 180)
                        local rescaleRollDegAbs = ((currentRollDegAbs - turnAssistRollThreshold) / (180 - turnAssistRollThreshold)) * 180
                        local rollVerticalRatio = 0
                        if rescaleRollDegAbs < 90 then
                            rollVerticalRatio = rescaleRollDegAbs / 90
                        elseif rescaleRollDegAbs < 180 then
                            rollVerticalRatio = (180 - rescaleRollDegAbs) / 90
                        end

                        rollVerticalRatio = rollVerticalRatio * rollVerticalRatio

                        local turnAssistYawInput = - currentRollDegSign * rollToYawFactor * (1.0 - rollVerticalRatio)
                        local turnAssistPitchInput = rollToPitchFactor * rollVerticalRatio

                        targetAngularVelocity = targetAngularVelocity
                                            + turnAssistPitchInput * constructRight
                                            + turnAssistYawInput * constructUp
                    end
                end

                -- Engine commands
                local keepCollinearity = 1 -- for easier reading
                local dontKeepCollinearity = 0 -- for easier reading
                local tolerancePercentToSkipOtherPriorities = 1 -- if we are within this tolerance (in%), we don't go to the next priorities

                -- Rotation
                local angularAcceleration = torqueFactor * (targetAngularVelocity - constructAngularVelocity)
                local airAcceleration = vec3(core.getWorldAirFrictionAngularAcceleration())
                angularAcceleration = angularAcceleration - airAcceleration -- Try to compensate air friction
                Nav:setEngineTorqueCommand('torque', angularAcceleration, keepCollinearity, 'airfoil', '', '', tolerancePercentToSkipOtherPriorities)

                -- Brakes
                --local brakeAcceleration = -finalBrakeInput * (brakeSpeedFactor * constructVelocity + brakeFlatFactor * constructVelocityDir)
                --Nav:setEngineForceCommand('brake', brakeAcceleration)
                if mpc.piloting.handbrake or mpc.piloting.autobrake or (finalBrakeInput > 0) then
                    mpc.piloting.isBraking = true
                else
                    mpc.piloting.isBraking = false
                end
                if mpc.piloting.handbrake then
                    unit.setEngineThrust("brake", math.maxinteger)
                else
                    local brakeAcceleration = (brakeSpeedFactor * constructVelocity + brakeFlatFactor * constructVelocityDir)
                    brakeAcceleration = mpc.piloting.autobrake and (-brakeAcceleration) or (-finalBrakeInput * brakeAcceleration)
                    Nav:setEngineForceCommand('brake', brakeAcceleration)
                end

                -- AutoNavigation regroups all the axis command by 'TargetSpeed'
                local autoNavigationEngineTags = ''
                local autoNavigationAcceleration = vec3()
                local autoNavigationUseBrake = false

                -- Longitudinal Translation
                local longitudinalEngineTags = 'thrust analog longitudinal'
                local longitudinalCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.longitudinal)
                if (longitudinalCommandType == axisCommandType.byThrottle) then
                    local longitudinalAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromThrottle(longitudinalEngineTags,axisCommandId.longitudinal)
                    Nav:setEngineForceCommand(longitudinalEngineTags, longitudinalAcceleration, keepCollinearity)
                elseif  (longitudinalCommandType == axisCommandType.byTargetSpeed) then
                    local longitudinalAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromTargetSpeed(axisCommandId.longitudinal)
                    autoNavigationEngineTags = autoNavigationEngineTags .. ' , ' .. longitudinalEngineTags
                    autoNavigationAcceleration = autoNavigationAcceleration + longitudinalAcceleration
                    if (Nav.axisCommandManager:getTargetSpeed(axisCommandId.longitudinal) == 0 or -- we want to stop
                        Nav.axisCommandManager:getCurrentToTargetDeltaSpeed(axisCommandId.longitudinal) < - Nav.axisCommandManager:getTargetSpeedCurrentStep(axisCommandId.longitudinal) * 0.5) -- if the longitudinal velocity would need some braking
                    then
                        autoNavigationUseBrake = true
                    end

                end

                -- Lateral Translation
                local lateralStrafeEngineTags = 'thrust analog lateral'
                local lateralCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.lateral)
                if (lateralCommandType == axisCommandType.byThrottle) then
                    local lateralStrafeAcceleration =  Nav.axisCommandManager:composeAxisAccelerationFromThrottle(lateralStrafeEngineTags,axisCommandId.lateral)
                    Nav:setEngineForceCommand(lateralStrafeEngineTags, lateralStrafeAcceleration, keepCollinearity)
                elseif  (lateralCommandType == axisCommandType.byTargetSpeed) then
                    local lateralAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromTargetSpeed(axisCommandId.lateral)
                    autoNavigationEngineTags = autoNavigationEngineTags .. ' , ' .. lateralStrafeEngineTags
                    autoNavigationAcceleration = autoNavigationAcceleration + lateralAcceleration
                end

                -- Vertical Translation
                local verticalStrafeEngineTags = 'thrust analog vertical'
                local verticalCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.vertical)
                if (verticalCommandType == axisCommandType.byThrottle) then
                    local verticalStrafeAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromThrottle(verticalStrafeEngineTags,axisCommandId.vertical)
                    Nav:setEngineForceCommand(verticalStrafeEngineTags, verticalStrafeAcceleration, keepCollinearity, 'airfoil', 'ground', '', tolerancePercentToSkipOtherPriorities)
                elseif  (verticalCommandType == axisCommandType.byTargetSpeed) then
                    local verticalAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromTargetSpeed(axisCommandId.vertical)
                    autoNavigationEngineTags = autoNavigationEngineTags .. ' , ' .. verticalStrafeEngineTags
                    autoNavigationAcceleration = autoNavigationAcceleration + verticalAcceleration
                end
                --Nav:setEngineForceCommand('booster_engine', 0)

                -- Auto Navigation (Cruise Control)
                if (autoNavigationAcceleration:len() > constants.epsilon) then
                    if (brakeInput ~= 0 or autoNavigationUseBrake or math.abs(constructVelocityDir:dot(constructForward)) < 0.95)  -- if the velocity is not properly aligned with the forward
                    then
                        autoNavigationEngineTags = autoNavigationEngineTags .. ', brake'
                    end
                    Nav:setEngineForceCommand(autoNavigationEngineTags, autoNavigationAcceleration, dontKeepCollinearity, '', '', '', tolerancePercentToSkipOtherPriorities)
                end

                -- Rockets
                Nav:setBoosterCommand('rocket_engine')

        update:
            lua: Nav:update()

        actionStart:
            args: [option4]
            lua: |
                if vboosterSwitch then
                    vboosterSwitch.toggle()
                    mpc.piloting.vboosters = not mpc.piloting.vboosters
                end

        actionStart:
            args: [option3]
            lua: |
                if lightSwitch then
                    lightSwitch.toggle()
                    mpc.piloting.lights = not mpc.piloting.lights
                end

        actionStart:
            args: [option2]
            lua: mpc.piloting.autobrake = not mpc.piloting.autobrake
        actionStart:
            args: [option1]
            lua: mpc.piloting.handbrake = not mpc.piloting.handbrake
        actionStart:
            args: [lalt]
            lua: mpc.bti.target = (mpc.bti.target - 1 + mpc.bti.maxWaypoints + 1) % mpc.bti.maxWaypoints + 1
        actionStart:
            args: [lshift]
            lua: mpc.bti.target = (mpc.bti.target - 1 + mpc.bti.maxWaypoints - 1) % mpc.bti.maxWaypoints + 1
        actionStart:
            args: [gear]
            lua: |
                gearExtended = not gearExtended
                if gearExtended then
                    Nav.control.extendLandingGears()
                else
                    Nav.control.retractLandingGears()
                end

        actionStart:
            args: [light]
            lua: |
                if Nav.control.isAnyHeadlightSwitchedOn() == 1 then
                    Nav.control.switchOffHeadlights()
                else
                    Nav.control.switchOnHeadlights()
                end

        actionStart:
            args: [forward]
            lua: pitchInput = pitchInput - 1
        actionStop:
            args: [forward]
            lua: pitchInput = pitchInput + 1
        actionStart:
            args: [backward]
            lua: pitchInput = pitchInput + 1
        actionStop:
            args: [backward]
            lua: pitchInput = pitchInput - 1
        actionStart:
            args: [left]
            lua: rollInput = rollInput - 1
        actionStop:
            args: [left]
            lua: rollInput = rollInput + 1
        actionStart:
            args: [right]
            lua: rollInput = rollInput + 1
        actionStop:
            args: [right]
            lua: rollInput = rollInput - 1

        actionStart:
            args: [straferight]
            lua: Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.lateral, 1.0)
        actionStop:
            args: [straferight]
            lua: Nav.axisCommandManager:updateCommandFromActionStop(axisCommandId.lateral, -1.0)

        actionStart:
            args: [strafeleft]
            lua: Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.lateral, -1.0)
        actionStop:
            args: [strafeleft]
            lua: Nav.axisCommandManager:updateCommandFromActionStop(axisCommandId.lateral, 1.0)

        actionStart:
            args: [up]
            lua: |
                Nav.axisCommandManager:deactivateGroundEngineAltitudeStabilization()
                Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.vertical, 1.0)
        actionStop:
            args: [up]
            lua: |
                Nav.axisCommandManager:updateCommandFromActionStop(axisCommandId.vertical, -1.0)
                Nav.axisCommandManager:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)
        actionStart:
            args: [down]
            lua: |
                Nav.axisCommandManager:deactivateGroundEngineAltitudeStabilization()
                Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.vertical, -1.0)
        actionStop:
            args: [down]
            lua: |
                Nav.axisCommandManager:updateCommandFromActionStop(axisCommandId.vertical, 1.0)
                Nav.axisCommandManager:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)

        actionStart:
            args: [groundaltitudeup]
            lua: Nav.axisCommandManager:updateTargetGroundAltitudeFromActionStart(1.0)

        actionLoop:
            args: [groundaltitudeup]
            lua: Nav.axisCommandManager:updateTargetGroundAltitudeFromActionLoop(1.0)


        actionStart:
            args: [groundaltitudedown]
            lua: Nav.axisCommandManager:updateTargetGroundAltitudeFromActionStart(-1.0)

        actionLoop:
            args: [groundaltitudedown]
            lua: Nav.axisCommandManager:updateTargetGroundAltitudeFromActionLoop(-1.0)

        actionStart:
            args: [yawright]
            lua: yawInput = yawInput - 1
        actionStop:
            args: [yawright]
            lua: yawInput = yawInput + 1
        actionStart:
            args: [yawleft]
            lua: yawInput = yawInput + 1
        actionStop:
            args: [yawleft]
            lua: yawInput = yawInput - 1
        actionStart:
            args: [brake]
            lua: |
                brakeInput = brakeInput + 1
                local longitudinalCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.longitudinal)
                if (longitudinalCommandType == axisCommandType.byTargetSpeed) then
                    local targetSpeed = Nav.axisCommandManager:getTargetSpeed(axisCommandId.longitudinal)
                    if (math.abs(targetSpeed) > constants.epsilon) then
                        Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.longitudinal, - utils.sign(targetSpeed))
                    end
                end
        actionStop:
            args: [brake]
            lua: brakeInput = brakeInput - 1

        actionLoop:
            args: [brake]
            lua: |
                local longitudinalCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.longitudinal)
                if (longitudinalCommandType == axisCommandType.byTargetSpeed) then
                    local targetSpeed = Nav.axisCommandManager:getTargetSpeed(axisCommandId.longitudinal)
                    if (math.abs(targetSpeed) > constants.epsilon) then
                        Nav.axisCommandManager:updateCommandFromActionLoop(axisCommandId.longitudinal, - utils.sign(targetSpeed))
                    end
                end
        actionStart:
            args: [booster]
            lua: Nav:toggleBoosters()
        actionStart:
            args: [stopengines]
            lua: Nav.axisCommandManager:resetCommand(axisCommandId.longitudinal)
        actionStart:
            args: [speedup]
            lua: Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.longitudinal, 5.0)
        actionLoop:
            args: [speedup]
            lua: Nav.axisCommandManager:updateCommandFromActionLoop(axisCommandId.longitudinal, 1.0)
        actionStart:
            args: [speeddown]
            lua: Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.longitudinal, -5.0)
        actionLoop:
            args: [speeddown]
            lua: Nav.axisCommandManager:updateCommandFromActionLoop(axisCommandId.longitudinal, -1.0)
        actionStart:
            args: [antigravity]
            lua: if antigrav ~= nil then antigrav.toggle() end

    library:
        start:
            lua: |
                -- util
                function	getTankMaxVolume(tank, talentlvl)
                    local defaultTanksMass = {35.03, 182.67, 988.67, 5481.27} -- xs, s, m, l
                    local defaultTanksVolumes= {100, 400, 1600, 12800} -- xs, s, m, l
                    local mass = tank.getSelfMass()
                    local vol = 0
                    for i, m in pairs(defaultTanksMass) do
                        if mass == m then
                            vol = defaultTanksVolumes[i] * (1 + 0.20*talentlvl) -- 20% bonus volume / lvl
                            break
                        end
                    end
                    assert(vol ~= 0, "error 404: tank volume not found")
                    return math.ceil(vol)
                end

                function	getTankPercent(tank, volume, fuelMassL)
                    local mm = volume * fuelMassL
                    local m = tank.getItemsMass()
                    return math.ceil(m / mm * 100)
                end

                function	calcBrakeTimeAndDistance(mass, speed, brakePower)
                    mass = mass / 1 -- convert to kg
                    local c = 8333.34
                    local v = speed
                    local ds = (c*c*mass) / (brakePower) * (1 - math.sqrt(1 - ((speed*speed)/(c*c))))
                    local t = mass * (c/brakePower) * math.asin(v/c)
                    return {distance = ds, time = t}
                end

        start:
            lua: |
                --[[
                    MPC v1.3

                    links (element : slot name) (* are optional):
                        - core : core
                        * telemeter : telemeter 
                        * lightSwitch : manual switch (with relay(s) to all lights)
                        * vboosterSwitch : manual switch (with relay(s) to all fuel intakes)
                    
                    commands:
                        option1 : toggle handbrake
                        option2 : toggle brakes
                        option3 : toggle lights
                        option4 : toggle vboosters

                    todo:
                        basic interface:
                            fuel tank : time to depletion
                        settings: toggle space brake safety if <2su (dep: BTI)

                --]]

                local function dhms(time, displayAll, sep)
                    displayAll = displayAll or false
                    sep = sep or {"d","h","m","s"}
                    local dhmsValues = {86400, 3600, 60, 1}
                    local res = ""
                    for i, v in ipairs(dhmsValues) do
                        local r = math.floor(time / dhmsValues[i])
                        time = time % dhmsValues[i]
                        if displayAll or r ~= 0 then
                            res = res .. string.format([[%.2d%s]], r, sep[i])
                        end
                    end
                    return res ~= "" and res or ("0"..sep[4])
                end
                local function    sukm(distance, displayAll, sep)
                    displayAll = displayAll or false
                    sep = sep or {"su","k","m"}
                    local sukmValues = {200000, 1000, 1}
                    local res = ""
                    for i, v in ipairs(sukmValues) do
                        local r = math.floor(distance / sukmValues[i])
                        distance = distance % sukmValues[i]
                        if displayAll or r ~= 0 then
                            res = res .. string.format([[%.3d%s]], r, sep[i])
                        end
                    end
                    return res ~= "" and res or ("0"..sep[3])
                end
                local function roundStr(num, numDecimalPlaces)
                    return string.format("%." .. (numDecimalPlaces or 0) .. "f", num)
                end
                local function    fancy_sukm(distance, thresholds)
                    thresholds = thresholds or {km=200000, m=10000}
                    --display in su/km/m depending on its distance
                    if (distance < thresholds.m) then
                        distance = roundStr(distance, 0) .. " m"
                    elseif (distance < thresholds.km) then
                        distance = roundStr(distance / 1000, 1) .. " km"
                    else
                        distance = roundStr(distance / 200000, 2) .. " su"
                    end
                    return distance
                end

                function    requireMinimalPilotingConfig(atmotanks, spacetanks)
                    local mpc = {
                        piloting = {
                            handbrake = false,
                            autobrake = false,
                            vBoosters = true,
                            brakeAtRange = false, -- default 2su
                            lights = false,
                            gears = false,
                            telemeterRange = 0,
                            surfaceStabilization = 4, --m
                        },
                        atmotanks = atmotanks,
                        spacetanks = spacetanks,
                        nitronMass = 4,
                        kergonMass = 6,
                        gearsThreshold = 40,
                        uiPos = vec3(1675, 495, 0),
                    }

                    function	mpc:initTanksData(
                            ContainerOptimization,
                            FuelTankOptimization,
                            AtmosphericFuelTankHandling,
                            SpaceFuelTankHandling)
                    
                        self.nitronMass = 4 * (1 - 0.05*(ContainerOptimization + FuelTankOptimization))
                        self.kergonMass = 6 * (1 - 0.05*(ContainerOptimization + FuelTankOptimization))
                        for _, t in pairs(self.atmotanks) do
                            t.volume = getTankMaxVolume(t, AtmosphericFuelTankHandling)
                            t.percent = getTankPercent(t, t.volume, self.nitronMass)
                        end
                        for _, t in pairs(self.spacetanks) do
                            t.volume = getTankMaxVolume(t, SpaceFuelTankHandling)
                            t.percent = getTankPercent(t, t.volume, self.kergonMass)
                        end
                    end

                    function    mpc:updateTanksPercent()
                        for _, t in pairs(self.atmotanks) do
                            t.percent = getTankPercent(t, t.volume, self.nitronMass)
                        end
                        for _, t in pairs(self.spacetanks) do
                            t.percent = getTankPercent(t, t.volume, self.kergonMass)
                        end
                    end
                    function    mpc:getSvgFuelGauge(pos, right2left)
                        pos = pos and vec3(pos) or vec3(10, 100, 0)
                        local r = 8
                        local spacing = math.ceil(r*3)
                        if right2left then spacing = -spacing end
                        local svgcode = ""
                        svgcode = svgcode .. [[
                            <g class="fuel">
                            <g class="nitron">
                        ]]
                        for i, t in pairs(self.atmotanks) do
                            svgcode = svgcode .. svgCircularGauge(t.percent, pos + i*vec3(spacing,0,0), r, "gauge", "gauge-bg")
                        end
                        svgcode = svgcode .. [[</g><g class="kergon">]]
                        pos = pos + vec3(0, math.abs(spacing), 0)
                        for i, t in pairs(self.spacetanks) do
                            svgcode = svgcode .. svgCircularGauge(t.percent, pos + i*vec3(spacing,0,0), r, "gauge", "gauge-bg")
                        end
                        svgcode = svgcode .. [[</g></g>]]
                        return svgcode
                    end

                    function    mpc:updatePilotingInfos()
                        --self.piloting.throttle = unit.getThrottle() --unit.getAxisCommandValue(0) * 100, -- Longitudinal = 0, lateral = 1, vertical = 2    //  unit.getThrottle()
                        self.piloting.surfaceStabilization = unit.getSurfaceEngineAltitudeStabilization() -- meter
                        self.piloting.telemeterRange = telemeter and telemeter.getDistance() or nil
                        self.piloting.gears = unit.isAnyLandingGearExtended()
                        --self.piloting.isBraking = ??, -- done in flush
                    end
                    function    mpc:getSvgPilotingInfos(pos)
                        pos = pos and vec3(pos) or vec3(self.uiPos)
                        local fontsize = 14
                        local colorOn = "#33cc33"
                        local color = "#99ccff"
                        local svgcode = ""
                        svgcode = svgcode .. svgTextBG("Braking", pos + vec3(0,-20,0), fontsize, (self.piloting.isBraking) and colorOn or color)
                        svgcode = svgcode .. svgTextBG("HandBrake", pos + vec3(70,-20,0), fontsize, (self.piloting.handbrake) and colorOn or color)
                        svgcode = svgcode .. svgTextBG("AutoBrake", pos + vec3(157,-20,0), fontsize, (self.piloting.autobrake) and colorOn or color)
                        if lightSwitch then
                            svgcode = svgcode .. svgTextBG("Lights", pos + vec3(180,-40,0), fontsize, (self.piloting.lights) and colorOn or color)
                        end
                        if vboosterSwitch then
                            svgcode = svgcode .. svgTextBG("vBoosters", pos + vec3(94,-40,0), fontsize, (self.piloting.vboosters) and colorOn or color)
                        end
                        svgcode = svgcode .. svgTextBG("Gears", pos + vec3(41,-40,0), fontsize, (self.piloting.gears == 1) and colorOn or color)

                        --brake calc
                        local brakeData = calcBrakeTimeAndDistance(core.getConstructMass(), vec3(core.getWorldVelocity()):len(), self.brakePower)
                        local text1 = fancy_sukm(math.floor(brakeData.distance))
                        local text2 = " |  " .. dhms(brakeData.time)
                        svgcode = svgcode .. string.format([[
                            <g style="fill:%s;font-size:12;font-weight:bold;">
                                <text x="%d" y="%d" text-anchor="middle">Brake distance and time :</text>
                                <text x="%d" y="%d" text-anchor="end">%s</text>
                                <text x="%d" y="%d" >%s</text>
                            </g>]],
                            color,
                            pos.x+120, pos.y+10,
                            pos.x+120, pos.y+25, text1,
                            pos.x+123, pos.y+25, text2)

                        --floor dist and stabilization height
                        local maxRange = 100 -- telemeter 
                        local min = vec3(pos) + vec3(-15, 330, 0)
                        local direction = vec3(0, -300, 0)
                        local max = min + direction

                        local r = 0
                        local floor = 0
                        local floortext = ""
                        if self.piloting.telemeterRange then
                            r = math.ceil(self.piloting.telemeterRange)
                            r = r == -1 and 101 or r
                            floor = min + direction * (r / maxRange)
                            floor.x = math.ceil(floor.x)
                            floor.y = math.ceil(floor.y)
                            floortext = r == 101 and "100+" or r
                        else
                            floor = vec3(min)
                            floortext = "?"
                        end

                        local stab = min + direction * (self.piloting.surfaceStabilization / maxRange)
                        stab.x = math.ceil(stab.x)
                        stab.y = math.ceil(stab.y)
                        svgcode = svgcode .. string.format([[<line x1="%d" y1="%d" x2="%d" y2="%d" style="stroke:%s;stroke-width:2" />
                            <g style="fill:%s;font-size:12;font-weight:bold;">
                                <text x="%d" y="%d" text-anchor="end">%s</text>
                                <text x="%d" y="%d">%s</text>
                            </g>]],
                            min.x, min.y, max.x, max.y, color,
                            color, floor.x, floor.y, floortext .. " ►",
                            stab.x, stab.y, ("◄ " .. math.ceil(self.piloting.surfaceStabilization)))

                            --[[
                        svgcode = svgcode .. svg.toSVG({
                            core.getMaxKinematicsParametersAlongAxis(),
                            unit.computeGroundEngineAltitudeStabilizationCapabilities(),
                        }, 20, 200)
                            --]]
                        return svgcode
                    end

                    function    mpc:automaticFeatures()
                        --gears
                        if self.piloting.telemeterRange then
                            if (self.piloting.telemeterRange > 0) and (self.piloting.telemeterRange <= self.gearsThreshold) then
                                if self.piloting.gears == 0 then unit.extendLandingGears() end
                            else
                                if self.piloting.gears == 1 then unit.retractLandingGears() end
                            end
                        end
                        -- on brake: red backlight
                    end

                    function	mpc:getSvgcode()
                        local svgcode = ""
                        local atmolvls = {}
                        local spacelvls = {}
                        for _, t in pairs(self.atmotanks) do
                            table.insert(atmolvls, t.percent)
                        end
                        for _, t in pairs(self.spacetanks) do
                            table.insert(spacelvls, t.percent)
                        end
                        svgcode = svgcode .. self.bti:getSvgcode()
                        svgcode = svgcode .. self:getSvgFuelGauge(vec3(1800, 1030, 0), true) -- true = right2left
                        svgcode = svgcode .. self:getSvgPilotingInfos()

                --  svg.body = svg.body .. svg.toSVG({displayedMenu}, 900, 30, {maxDepth=1})
                        return svgcode
                    end

                    return mpc
                end


        start:
            lua: |
                -- BTI v1.1
                local function dhms(time, displayAll, sep)
                    displayAll = displayAll or false
                    sep = sep or {"d","h","m","s"}
                    local dhmsValues = {86400, 3600, 60, 1}
                    local res = ""
                    for i, v in ipairs(dhmsValues) do
                        local r = math.floor(time / dhmsValues[i])
                        time = time % dhmsValues[i]
                        if displayAll or r ~= 0 then
                            res = res .. string.format([[%.2d%s]], r, sep[i])
                        end
                    end
                    return res ~= "" and res or ("0"..sep[4])
                end

                function requireBasicTravelInfos()
                    --[[
                    dependency: SvgHelper
                    
                    unit > start
                        svg = requireSvgHelper() -- or require("svghelper")
                        bti = requireBasicTravelInfos()
                        system.showScreen(1)
                        unit.setTimer("eta", 0.25)
                    unit > tick(eta)
                        svg.body = bti:getSvgcode()
                        system.setScreen(svg.dump())
                    system > actionStart(lshift)
                        bti.target = (bti.target - 1 + bti.maxWaypoints - 1) % bti.maxWaypoints + 1
                    system > actionStart(lalt)
                        bti.target = (bti.target - 1 + bti.maxWaypoints + 1) % bti.maxWaypoints + 1

                    ]]
                    
                    local bti = {}
                    bti.waypoints = {
                        {name="Alioth", x=-8, y=-8, z=-126303},
                        {name="Madis", x=17465536, y=22665536, z=-34464},
                        {name="Thades", x=29165536, y=10865536, z=65536},
                        {name="Talemai", x=-13234464, y=55765536, z=465536},
                        {name="Feli", x=-43534464, y=22565536, z=-48934464},
                        {name="Sicari", x=52765536, y=27165536, z=52065536},
                        {name="Sinnen", x=58665536, y=29665536, z=58165536},
                        {name="Teoma", x=80865536, y=54665536, z=-934464},
                        {name="Jago", x=-94134464, y=12765536, z=-3634464},
                        {name="Symeon", x=14165536, y=-85634464, z=-934464},
                        {name="Ion", x=2865536, y=-99034464, z=-934464},
                        {name="Lacobus", x=98865536, y=-13534464, z=-934464}
                    }
                    bti.maxWaypoints = 0
                    for _, v in ipairs(bti.waypoints) do
                        bti.maxWaypoints = bti.maxWaypoints + 1
                    end
                    bti.target = 1


                    function	bti.travelInfos(target, shipPos, speed, mass, pos, fontsize)
                        fontsize = fontsize or 18
                        pos = pos and vec3(pos) or vec3(10, 30, 0)
                        local name = target.name or "?"
                        local dist = (shipPos - target):len()
                        local su = 200000
                        local t = 1000

                        local travel = {
                            atCurrentSpeed = math.floor(dist / speed),
                            atMaxSpeed = math.floor(dist / 8333),
                            warpCells = ((mass/t) * (dist/su) / 4000)
                        }

                        fontsize = fontsize or 20
                        local x = pos.x
                        local y = pos.y
                        local svgcode = string.format([[<g fill="%s" font-size="%dpx">]], "#99ccff", fontsize)
                        --title
                        svgcode = svgcode .. string.format([[
                            <text x="%d" y="%d" font-weight="bold" text-decoration="underline">Travel time to %s (%dsu) :</text>]],
                            x, y, target.name, math.ceil(dist/su))
                        --current speed
                        y = y + fontsize
                        svgcode = svgcode .. string.format([[
                            <text x="%d" y="%d">At current speed: %s</text>]],
                            x, y, travel.atCurrentSpeed == 1/0 and "∞" or dhms(travel.atCurrentSpeed))
                        --max speed
                        y = y + fontsize
                        svgcode = svgcode .. string.format([[
                            <text x="%d" y="%d">At max speed: %s</text>]],
                            x, y, dhms(travel.atMaxSpeed))
                        --warp cell
                        y = y + fontsize
                        svgcode = svgcode .. string.format([[
                            <text x="%d" y="%d">Warp cells for %dt : %s</text>]],
                            x, y, math.ceil(mass/t), math.ceil(travel.warpCells))

                        svgcode = svgcode .. [[</g>]]
                        return svgcode
                    end
                    
                    function	bti:getSvgcode(pos)
                        local speed = vec3(core.getWorldVelocity()):len()
                        local selectedTarget = self.waypoints[self.target]
                        local shipPos = vec3(core.getConstructWorldPos())
                        local mass = core.getConstructMass()

                        return self.travelInfos(selectedTarget, shipPos, speed, mass, pos, 18)
                    end
                    
                    return bti
                end


        start:
            lua: |
                function requireSvgHelper()
                    local function isTable(t)   return type(t) == 'table'  end

                    local svg = {}
                    svg._fontsize = 20
                    svg._pad = 4
                    svg._tablepad = 30
                    svg._textColor = "yellow"
                    svg._displayKey = true
                    svg._displayTable = true

                    function svg.dump()
                        return svg.header .. svg.style .. "</style><defs>" .. svg.base .. "</defs>" .. svg.body .. svg.footer
                    end

                    function svg.toSVG(arr, x, ystart, settings, depth)
                        local svgtext = ""
                        ystart = ystart or 20
                        x = x or 25
                        settings = settings or {}
                        settings.maxDepth = settings.maxDepth or 99999
                        if (settings.displayKey == nil) then settings.displayKey = svg._displayKey end
                        if (settings.displayTable == nil) then settings.displayTable = svg._displayTable end
                        depth = depth or 0

                        local i = 0
                        local ii = 0
                        for k, v in pairs(arr) do
                            i = i + 1
                            if (depth == 0) then ii = ii + 1 end
                            local valueIsTable = isTable(v)
                            svgtext = svgtext .. string.format([[
                                <text x="%d" y="%d"
                                font-size="%dpx" fill="%s" stroke="black" stroke-width="2">
                                %s%s
                                </text>
                                ]], x + depth*svg._tablepad, (ystart + (i + ii - 1)*(svg._fontsize + svg._pad)),
                                svg._fontsize, svg._textColor,
                                settings.displayKey and (k.." : ") or "", valueIsTable and "{...}" or v)
                            if (settings.displayTable and valueIsTable and (depth <= settings.maxDepth)) then
                                local svgtable, ret = svg.toSVG(v, x, (ystart + (i + ii)*(svg._fontsize + svg._pad)), settings, depth+1)
                                ii = ii + ret
                                svgtext = svgtext .. svgtable
                            end
                        end
                        return svgtext, i + ii
                    end

                    function svg.imageCut(path, imageSize, screenViewbox, svgViewbox) -- viewbox are rect: x y width height
                        return string.format([[
                            <svg x="%d" y="%d" width="%d" height="%d" preserveAspectRatio="none"
                            viewBox="%d %d %d %d"
                            xmlns="http://www.w3.org/2000/svg" 
                            xmlns:xlink="http://www.w3.org/1999/xlink"> 
                            <image width="%d" height="%d" xlink:href="%s" />
                            </svg>]],
                            screenViewbox.x, screenViewbox.y, screenViewbox.width, screenViewbox.height,
                            svgViewbox.x, svgViewbox.y, svgViewbox.width, svgViewbox.height,
                            imageSize.x, imageSize.y, path)
                    end

                    svg.header = [[

                    <svg class="svg"
                    width="1920" height="1080"
                    viewBox="0 0 1920 1080"
                    xmlns="http://www.w3.org/2000/svg" 
                    xmlns:xlink="http://www.w3.org/1999/xlink"> 
                    <style>
                    .svg {
                    position:absolute;
                    left: 0;
                    top: 0;
                    height: 100vh;
                    width: 100vw;
                    }
                    ]]
                    svg.style = [[]]
                    svg.base = [[]]
                    svg.footer = [[</svg>]]
                    svg.body = [[]]

                    return svg
                end

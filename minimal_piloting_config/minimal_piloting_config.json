{"slots":{"0":{"name":"core","type":{"events":[],"methods":[]}},"1":{"name":"warpdrive","type":{"events":[],"methods":[]}},"2":{"name":"spacefueltank_1","type":{"events":[],"methods":[]}},"3":{"name":"spacefueltank_2","type":{"events":[],"methods":[]}},"4":{"name":"atmofueltank_1","type":{"events":[],"methods":[]}},"5":{"name":"atmofueltank_2","type":{"events":[],"methods":[]}},"6":{"name":"atmofueltank_3","type":{"events":[],"methods":[]}},"7":{"name":"lightSwitch","type":{"events":[],"methods":[]}},"8":{"name":"telemeter","type":{"events":[],"methods":[]}},"9":{"name":"slot10","type":{"events":[],"methods":[]}},"10":{"name":"slot11","type":{"events":[],"methods":[]}},"11":{"name":"slot12","type":{"events":[],"methods":[]}},"12":{"name":"slot13","type":{"events":[],"methods":[]}},"13":{"name":"slot14","type":{"events":[],"methods":[]}},"14":{"name":"slot15","type":{"events":[],"methods":[]}},"15":{"name":"slot16","type":{"events":[],"methods":[]}},"16":{"name":"slot17","type":{"events":[],"methods":[]}},"17":{"name":"slot18","type":{"events":[],"methods":[]}},"18":{"name":"slot19","type":{"events":[],"methods":[]}},"19":{"name":"slot20","type":{"events":[],"methods":[]}},"20":{"name":"radar_1","type":{"events":[],"methods":[]}},"-1":{"name":"unit","type":{"events":[],"methods":[]}},"-2":{"name":"system","type":{"events":[],"methods":[]}},"-3":{"name":"library","type":{"events":[],"methods":[]}}},"handlers":[{"code":"_autoconf.hideCategoryPanels()\nif antigrav ~= nil then antigrav.hide() end\nif warpdrive ~= nil then warpdrive.hide() end\nif gyro ~= nil then gyro.hide() end\ncore.hide()\nNav.control.switchOffHeadlights()\n\n----------\nif lightSwitch then\n    lightSwitch.deactivate()\nend","filter":{"args":[],"signature":"stop()","slotKey":"-1"},"key":"0"},{"code":"-- category panel display helpers\n_autoconf = {}\n_autoconf.panels = {}\n_autoconf.panels_size = 0\n_autoconf.displayCategoryPanel = function(elements, size, title, type, widgetPerData)\n    widgetPerData = widgetPerData or false -- default to one widget for all data\n    if size > 0 then\n        local panel = system.createWidgetPanel(title)\n        local widget\n        if not widgetPerData then\n            widget = system.createWidget(panel, type)\n        end\n        for i = 1, size do\n            if widgetPerData then\n                widget = system.createWidget(panel, type)\n            end\n            system.addDataToWidget(elements[i].getDataId(), widget)\n        end\n        _autoconf.panels_size = _autoconf.panels_size + 1\n        _autoconf.panels[_autoconf.panels_size] = panel\n    end\nend\n_autoconf.hideCategoryPanels = function()\n    for i=1,_autoconf.panels_size do\n        system.destroyWidgetPanel(_autoconf.panels[i])\n    end\nend\n-- Proxy array to access auto-plugged slots programmatically\n\nspacefueltank = {}\nspacefueltank[1] = spacefueltank_1\nspacefueltank[2] = spacefueltank_2\nspacefueltank_size = 2\n\natmofueltank = {}\natmofueltank[1] = atmofueltank_1\natmofueltank[2] = atmofueltank_2\natmofueltank[3] = atmofueltank_3\natmofueltank_size = 3\n\nrocketfueltank = {}\nrocketfueltank_size = 0\n\nweapon = {}\nweapon_size = 0\n\nradar = {}\nradar[1] = radar_1\nradar_size = 1\n-- End of auto-generated code\npitchInput = 0\nrollInput = 0\nyawInput = 0\nbrakeInput = 0\n\nNav = Navigator.new(system, core, unit)\nNav.axisCommandManager:setupCustomTargetSpeedRanges(axisCommandId.longitudinal, {1000, 5000, 10000, 20000, 30000})\nNav.axisCommandManager:setTargetGroundAltitude(4)\n\n-- element widgets\n-- For now we have to alternate between PVP and non-PVP widgets to have them on the same side.\n--[[\n_autoconf.displayCategoryPanel(weapon, weapon_size, \"Weapons\", \"weapon\", true)\ncore.show()\n_autoconf.displayCategoryPanel(radar, radar_size, \"Periscope\", \"periscope\")\nplaceRadar = true\nif atmofueltank_size > 0 then\n    _autoconf.displayCategoryPanel(atmofueltank, atmofueltank_size, \"Atmo Fuel\", \"fuel_container\")\n    if placeRadar then\n        _autoconf.displayCategoryPanel(radar, radar_size, \"Radar\", \"radar\")\n        placeRadar = false\n    end\nend\nif spacefueltank_size > 0 then\n    _autoconf.displayCategoryPanel(spacefueltank, spacefueltank_size, \"Space Fuel\", \"fuel_container\")\n    if placeRadar then\n        _autoconf.displayCategoryPanel(radar, radar_size, \"Radar\", \"radar\")\n        placeRadar = false\n    end\nend\n_autoconf.displayCategoryPanel(rocketfueltank, rocketfueltank_size, \"Rocket Fuel\", \"fuel_container\")\nif placeRadar then -- We either have only rockets or no fuel tanks at all, uncommon for usual vessels\n    _autoconf.displayCategoryPanel(radar, radar_size, \"Radar\", \"radar\")\n    placeRadar = false\nend\n--]]\nif antigrav ~= nil then antigrav.show() end\nif warpdrive ~= nil then warpdrive.show() end\nif gyro ~= nil then gyro.show() end\n\n-- freeze the player in he is remote controlling the construct\nif Nav.control.isRemoteControlled() == 1 then\n    system.freeze(1)\nend\n\n-- landing gear\n-- make sure every gears are synchonized with the first\ngearExtended = (Nav.control.isAnyLandingGearExtended() == 1) -- make sure it's a lua boolean\nif gearExtended then\n    Nav.control.extendLandingGears()\nelse\n    Nav.control.retractLandingGears()\nend\n\n---------\nunit.setTimer(\"draw\", 0.01)\nlocal atmotanks = {atmofueltank_1,atmofueltank_2,atmofueltank_3,atmofueltank_4,atmofueltank_5,atmofueltank_6,atmofueltank_7,atmofueltank_8,atmofueltank_9,atmofueltank_10,atmofueltank_11,atmofueltank_12,atmofueltank_13,atmofueltank_14,atmofueltank_15,atmofueltank_16,atmofueltank_17,atmofueltank_18,atmofueltank_19,atmofueltank_20,}\nlocal spacetanks = {spacefueltank_1,spacefueltank_2,spacefueltank_3,spacefueltank_4,spacefueltank_5,spacefueltank_6,spacefueltank_7,spacefueltank_8,spacefueltank_9,spacefueltank_10,spacefueltank_11,spacefueltank_12,spacefueltank_13,spacefueltank_14,spacefueltank_15,spacefueltank_16,spacefueltank_17,spacefueltank_18,spacefueltank_19,spacefueltank_20,}\n--export variables:\nlocal ContainerOptimization = 5 --export\nlocal FuelTankOptimization = 5 --export\nlocal AtmosphericFuelTankHandling = 5 --export\nlocal SpaceFuelTankHandling = 4 --export\nlocal gearsThreshold = 40 --export\nlocal spaceBrakePower = 19179000 --export\n\nsvg = requireSvgHelper() -- or require(\"svghelper\")\nsvg.style = svg.style .. [[\n.fuel { fill: none; }\n.nitron { stroke: #3399ff; }\n.kergon { stroke: #ffff4d; }\n.gauge { stroke-width: 6; }\n.gauge-bg { stroke: #bbbbbb; stroke-width: 3; }\n.val { font-size: 20px; text-anchor: middle; fill: #bbbbbb; stroke: #bbbbbb; }\n]]\nmpc = requireMinimalPilotingConfig(atmotanks, spacetanks)\nmpc:initTanksData(ContainerOptimization, FuelTankOptimization, AtmosphericFuelTankHandling, SpaceFuelTankHandling)\nmpc.gearsThreshold = gearsThreshold\nmpc.brakePower = spaceBrakePower\n\nsystem.showScreen(1)\nunit.setTimer(\"hud\", 0.25)\nif lightSwitch then lightSwitch.activate()\n    mpc.lights = true\nend\n\n\n\n","filter":{"args":[],"signature":"start()","slotKey":"-1"},"key":"1"},{"code":"\nmpc:updateTanksPercent()\nmpc:updatePilotingInfos()\nmpc:automaticFeatures()\n\nsvg.body = mpc:getSvgcode()\nsystem.setScreen(svg.dump())","filter":{"args":[{"value":"hud"}],"signature":"tick(timerId)","slotKey":"-1"},"key":"2"},{"code":"-- draw\nfunction    svgCircularGauge(percent, pos, r, class, bgclass)\n    pos = vec3(pos)\n    class = class or \"gauge\"\n    bgclass = bgclass or \"gauge-bg\"\n    local size = r*2\n    local da = \"\"\n    if percent ~= 100 then\n        local d = math.ceil(2 * math.pi * r)+1\n        local p = math.ceil(d * percent / 100)\n        da = string.format([[ stroke-dasharray=\"%d %d\"]], p, d)\n    end\n    return string.format([[\n        <circle class=\"%s\" cx=\"%d\" cy=\"%d\" r=\"%d\"/>\n        <rect class=\"%s\" x=\"%d\" y=\"%d\" width=\"%d\" height=\"%d\" rx=\"%d\" ry=\"%d\"%s/>]],\n        bgclass, pos.x, pos.y, r,\n        class, pos.x-r, pos.y-r, size, size, r, r, da)\n--<circle class=\"%s\" cx=\"%d\" cy=\"%d\" r=\"%d\" stroke-dasharray=\"5 10\" />\nend\n\nfunction\tsvgTextBG(text, position, fontsize, color, inverted)--inverted is like an unselected button\n    local pos = position and {x=position.x, y=position.y} or {x=0, y=0}\n    fontsize = fontsize and math.floor(fontsize) or 15\n    color = color or \"white\"\n    inverted = inverted or false\n    local textcolor = inverted and color or \"black\"\n    local stroke = inverted and (\"stroke-width:1;stroke:\" .. color) or \"\"\n    color = inverted and \"none\" or color\n    local x = math.floor(pos.x)\n    local y = math.floor(pos.y)\n    local pad = 0.35\n    local textlen = math.floor(fontsize * string.len(text) * 0.6) --depend of the font\n    local xlen = math.floor(fontsize*pad*2) + textlen\n    local ylen = math.floor(fontsize*(1+pad))\n    local round = math.floor(fontsize*0.4)\n    \n    local svgcode = string.format([[\n        <rect x=\"%d\" y=\"%d\" width=\"%d\" height=\"%d\" rx=\"%d\" ry=\"%d\" style=\"fill:%s;%s\" />\n        <text x=\"%d\" y=\"%d\" textLength=\"%d\" font-size=\"%d\" font-weight=\"bold\" fill=\"%s\">%s</text>]],\n        x, y, xlen, ylen, round, round, color, stroke,\n        x + math.floor(fontsize*pad), y + fontsize, textlen, fontsize, textcolor, text)\n    \n    return svgcode\nend\n\nunit.stopTimer(\"draw\")","filter":{"args":[{"value":"draw"}],"signature":"tick(timerId)","slotKey":"-1"},"key":"3"},{"code":"Nav.axisCommandManager:resetCommand(axisCommandId.longitudinal)","filter":{"args":[{"value":"stopengines"}],"signature":"actionStart(stopengines)","slotKey":"-2"},"key":"4"},{"code":"Nav:toggleBoosters()","filter":{"args":[{"value":"booster"}],"signature":"actionStart(booster)","slotKey":"-2"},"key":"5"},{"code":"Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.longitudinal, 5.0)","filter":{"args":[{"value":"speedup"}],"signature":"actionStart(speedup)","slotKey":"-2"},"key":"6"},{"code":"Nav.axisCommandManager:updateCommandFromActionLoop(axisCommandId.longitudinal, 1.0)","filter":{"args":[{"value":"speedup"}],"signature":"actionLoop(speedup)","slotKey":"-2"},"key":"7"},{"code":"Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.longitudinal, -5.0)","filter":{"args":[{"value":"speeddown"}],"signature":"actionStart(speeddown)","slotKey":"-2"},"key":"8"},{"code":"Nav.axisCommandManager:updateCommandFromActionLoop(axisCommandId.longitudinal, -1.0)","filter":{"args":[{"value":"speeddown"}],"signature":"actionLoop(speeddown)","slotKey":"-2"},"key":"9"},{"code":"if antigrav ~= nil then antigrav.toggle() end","filter":{"args":[{"value":"antigravity"}],"signature":"actionStart(antigravity)","slotKey":"-2"},"key":"10"},{"code":"Nav.axisCommandManager:updateTargetGroundAltitudeFromActionStart(-1.0)","filter":{"args":[{"value":"groundaltitudedown"}],"signature":"actionStart(groundaltitudedown)","slotKey":"-2"},"key":"11"},{"code":"Nav.axisCommandManager:updateTargetGroundAltitudeFromActionLoop(-1.0)","filter":{"args":[{"value":"groundaltitudedown"}],"signature":"actionLoop(groundaltitudedown)","slotKey":"-2"},"key":"12"},{"code":"Nav.axisCommandManager:updateTargetGroundAltitudeFromActionLoop(1.0)","filter":{"args":[{"value":"groundaltitudeup"}],"signature":"actionLoop(groundaltitudeup)","slotKey":"-2"},"key":"13"},{"code":"yawInput = yawInput + 1","filter":{"args":[{"value":"yawright"}],"signature":"actionStop(yawright)","slotKey":"-2"},"key":"14"},{"code":"yawInput = yawInput + 1","filter":{"args":[{"value":"yawleft"}],"signature":"actionStart(yawleft)","slotKey":"-2"},"key":"15"},{"code":"yawInput = yawInput - 1","filter":{"args":[{"value":"yawright"}],"signature":"actionStart(yawright)","slotKey":"-2"},"key":"16"},{"code":"brakeInput = brakeInput + 1\nlocal longitudinalCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.longitudinal)\nif (longitudinalCommandType == axisCommandType.byTargetSpeed) then\n    local targetSpeed = Nav.axisCommandManager:getTargetSpeed(axisCommandId.longitudinal)\n    if (math.abs(targetSpeed) > constants.epsilon) then\n        Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.longitudinal, - utils.sign(targetSpeed))\n    end\nend\n","filter":{"args":[{"value":"brake"}],"signature":"actionStart(brake)","slotKey":"-2"},"key":"17"},{"code":"yawInput = yawInput - 1","filter":{"args":[{"value":"yawleft"}],"signature":"actionStop(yawleft)","slotKey":"-2"},"key":"18"},{"code":"brakeInput = brakeInput - 1","filter":{"args":[{"value":"brake"}],"signature":"actionStop(brake)","slotKey":"-2"},"key":"19"},{"code":"local longitudinalCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.longitudinal)\nif (longitudinalCommandType == axisCommandType.byTargetSpeed) then\n    local targetSpeed = Nav.axisCommandManager:getTargetSpeed(axisCommandId.longitudinal)\n    if (math.abs(targetSpeed) > constants.epsilon) then\n        Nav.axisCommandManager:updateCommandFromActionLoop(axisCommandId.longitudinal, - utils.sign(targetSpeed))\n    end\nend\n","filter":{"args":[{"value":"brake"}],"signature":"actionLoop(brake)","slotKey":"-2"},"key":"20"},{"code":"Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.lateral, -1.0)","filter":{"args":[{"value":"strafeleft"}],"signature":"actionStart(strafeleft)","slotKey":"-2"},"key":"21"},{"code":"Nav.axisCommandManager:updateCommandFromActionStop(axisCommandId.lateral, 1.0)","filter":{"args":[{"value":"strafeleft"}],"signature":"actionStop(strafeleft)","slotKey":"-2"},"key":"22"},{"code":"Nav.axisCommandManager:deactivateGroundEngineAltitudeStabilization()\nNav.axisCommandManager:updateCommandFromActionStart(axisCommandId.vertical, 1.0)\n","filter":{"args":[{"value":"up"}],"signature":"actionStart(up)","slotKey":"-2"},"key":"23"},{"code":"Nav.axisCommandManager:updateCommandFromActionStop(axisCommandId.vertical, -1.0)\nNav.axisCommandManager:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)\n","filter":{"args":[{"value":"up"}],"signature":"actionStop(up)","slotKey":"-2"},"key":"24"},{"code":"Nav.axisCommandManager:deactivateGroundEngineAltitudeStabilization()\nNav.axisCommandManager:updateCommandFromActionStart(axisCommandId.vertical, -1.0)\n","filter":{"args":[{"value":"down"}],"signature":"actionStart(down)","slotKey":"-2"},"key":"25"},{"code":"Nav.axisCommandManager:updateCommandFromActionStop(axisCommandId.vertical, 1.0)\nNav.axisCommandManager:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)\n","filter":{"args":[{"value":"down"}],"signature":"actionStop(down)","slotKey":"-2"},"key":"26"},{"code":"Nav.axisCommandManager:updateTargetGroundAltitudeFromActionStart(1.0)","filter":{"args":[{"value":"groundaltitudeup"}],"signature":"actionStart(groundaltitudeup)","slotKey":"-2"},"key":"27"},{"code":"Nav:update()","filter":{"args":[],"signature":"update()","slotKey":"-2"},"key":"28"},{"code":"gearExtended = not gearExtended\nif gearExtended then\n    Nav.control.extendLandingGears()\nelse\n    Nav.control.retractLandingGears()\nend\n","filter":{"args":[{"value":"gear"}],"signature":"actionStart(gear)","slotKey":"-2"},"key":"29"},{"code":"if (not mpc) or (not mpc.piloting) then\n    return\nend\n\n\n-- constants: use 'myvar = defaultValue --export: description' to expose the variable in context menu\n\nlocal pitchSpeedFactor = 0.8 --export: This factor will increase/decrease the player input along the pitch axis<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01\nlocal yawSpeedFactor =  1 --export: This factor will increase/decrease the player input along the yaw axis<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01\nlocal rollSpeedFactor = 1.5 --export: This factor will increase/decrease the player input along the roll axis<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01\n\nlocal brakeSpeedFactor = 3 --export: When braking, this factor will increase the brake force by brakeSpeedFactor * velocity<br>Valid values: Superior or equal to 0.01\nlocal brakeFlatFactor = 1 --export: When braking, this factor will increase the brake force by a flat brakeFlatFactor * velocity direction><br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01\n\nlocal autoRoll = false --export: [Only in atmosphere]<br>When the pilot stops rolling,  flight model will try to get back to horizontal (no roll)\nlocal autoRollFactor = 2 --export: [Only in atmosphere]<br>When autoRoll is engaged, this factor will increase to strength of the roll back to 0<br>Valid values: Superior or equal to 0.01\n\nlocal turnAssist = true --export: [Only in atmosphere]<br>When the pilot is rolling, the flight model will try to add yaw and pitch to make the construct turn better<br>The flight model will start by adding more yaw the more horizontal the construct is and more pitch the more vertical it is\nlocal turnAssistFactor = 2 --export: [Only in atmosphere]<br>This factor will increase/decrease the turnAssist effect<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01\n\nlocal torqueFactor = 2 -- Force factor applied to reach rotationSpeed<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01\n\n-- validate params\npitchSpeedFactor = math.max(pitchSpeedFactor, 0.01)\nyawSpeedFactor = math.max(yawSpeedFactor, 0.01)\nrollSpeedFactor = math.max(rollSpeedFactor, 0.01)\ntorqueFactor = math.max(torqueFactor, 0.01)\nbrakeSpeedFactor = math.max(brakeSpeedFactor, 0.01)\nbrakeFlatFactor = math.max(brakeFlatFactor, 0.01)\nautoRollFactor = math.max(autoRollFactor, 0.01)\nturnAssistFactor = math.max(turnAssistFactor, 0.01)\n\n-- final inputs\nlocal finalPitchInput = pitchInput + system.getControlDeviceForwardInput()\nlocal finalRollInput = rollInput + system.getControlDeviceYawInput()\nlocal finalYawInput = yawInput - system.getControlDeviceLeftRightInput()\nlocal finalBrakeInput = brakeInput\n\n-- Axis\nlocal worldVertical = vec3(core.getWorldVertical()) -- along gravity\nlocal constructUp = vec3(core.getConstructWorldOrientationUp())\nlocal constructForward = vec3(core.getConstructWorldOrientationForward())\nlocal constructRight = vec3(core.getConstructWorldOrientationRight())\nlocal constructVelocity = vec3(core.getWorldVelocity())\nlocal constructVelocityDir = vec3(core.getWorldVelocity()):normalize()\nlocal currentRollDeg = getRoll(worldVertical, constructForward, constructRight)\nlocal currentRollDegAbs = math.abs(currentRollDeg)\nlocal currentRollDegSign = utils.sign(currentRollDeg)\n\n-- Rotation\nlocal constructAngularVelocity = vec3(core.getWorldAngularVelocity())\nlocal targetAngularVelocity = finalPitchInput * pitchSpeedFactor * constructRight\n                                + finalRollInput * rollSpeedFactor * constructForward\n                                + finalYawInput * yawSpeedFactor * constructUp\n\n-- In atmosphere?\nif worldVertical:len() > 0.01 and unit.getAtmosphereDensity() > 0.0 then\n    local autoRollRollThreshold = 1.0\n    -- autoRoll on AND currentRollDeg is big enough AND player is not rolling\n    if autoRoll == true and currentRollDegAbs > autoRollRollThreshold and finalRollInput == 0 then\n        local targetRollDeg = utils.clamp(0,currentRollDegAbs-30, currentRollDegAbs+30);  -- we go back to 0 within a certain limit\n        if (rollPID == nil) then\n            rollPID = pid.new(autoRollFactor * 0.01, 0, autoRollFactor * 0.1) -- magic number tweaked to have a default factor in the 1-10 range\n        end\n        rollPID:inject(targetRollDeg - currentRollDeg)\n        local autoRollInput = rollPID:get()\n\n        targetAngularVelocity = targetAngularVelocity + autoRollInput * constructForward\n    end\n    local turnAssistRollThreshold = 20.0\n    -- turnAssist AND currentRollDeg is big enough AND player is not pitching or yawing\n    if turnAssist == true and currentRollDegAbs > turnAssistRollThreshold and finalPitchInput == 0 and finalYawInput == 0 then\n        local rollToPitchFactor = turnAssistFactor * 0.1 -- magic number tweaked to have a default factor in the 1-10 range\n        local rollToYawFactor = turnAssistFactor * 0.025 -- magic number tweaked to have a default factor in the 1-10 range\n\n        -- rescale (turnAssistRollThreshold -> 180) to (0 -> 180)\n        local rescaleRollDegAbs = ((currentRollDegAbs - turnAssistRollThreshold) / (180 - turnAssistRollThreshold)) * 180\n        local rollVerticalRatio = 0\n        if rescaleRollDegAbs < 90 then\n            rollVerticalRatio = rescaleRollDegAbs / 90\n        elseif rescaleRollDegAbs < 180 then\n            rollVerticalRatio = (180 - rescaleRollDegAbs) / 90\n        end\n\n        rollVerticalRatio = rollVerticalRatio * rollVerticalRatio\n\n        local turnAssistYawInput = - currentRollDegSign * rollToYawFactor * (1.0 - rollVerticalRatio)\n        local turnAssistPitchInput = rollToPitchFactor * rollVerticalRatio\n\n        targetAngularVelocity = targetAngularVelocity\n                            + turnAssistPitchInput * constructRight\n                            + turnAssistYawInput * constructUp\n    end\nend\n\n-- Engine commands\nlocal keepCollinearity = 1 -- for easier reading\nlocal dontKeepCollinearity = 0 -- for easier reading\nlocal tolerancePercentToSkipOtherPriorities = 1 -- if we are within this tolerance (in%), we don't go to the next priorities\n\n-- Rotation\nlocal angularAcceleration = torqueFactor * (targetAngularVelocity - constructAngularVelocity)\nlocal airAcceleration = vec3(core.getWorldAirFrictionAngularAcceleration())\nangularAcceleration = angularAcceleration - airAcceleration -- Try to compensate air friction\nNav:setEngineTorqueCommand('torque', angularAcceleration, keepCollinearity, 'airfoil', '', '', tolerancePercentToSkipOtherPriorities)\n\n-- Brakes\n--local brakeAcceleration = -finalBrakeInput * (brakeSpeedFactor * constructVelocity + brakeFlatFactor * constructVelocityDir)\n--Nav:setEngineForceCommand('brake', brakeAcceleration)\nif mpc.handbrake or mpc.autobrake or (finalBrakeInput > 0) then\n    mpc.piloting.brakingPower = 1\nelse\n    mpc.piloting.brakingPower = 0\nend\nif mpc.handbrake then\n    unit.setEngineThrust(\"brake\", math.maxinteger)\nelse\n    local brakeAcceleration = (brakeSpeedFactor * constructVelocity + brakeFlatFactor * constructVelocityDir)\n    brakeAcceleration = mpc.autobrake and (-brakeAcceleration) or (-finalBrakeInput * brakeAcceleration)\n    Nav:setEngineForceCommand('brake', brakeAcceleration)\nend\n\n-- AutoNavigation regroups all the axis command by 'TargetSpeed'\nlocal autoNavigationEngineTags = ''\nlocal autoNavigationAcceleration = vec3()\nlocal autoNavigationUseBrake = false\n\n-- Longitudinal Translation\nlocal longitudinalEngineTags = 'thrust analog longitudinal'\nlocal longitudinalCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.longitudinal)\nif (longitudinalCommandType == axisCommandType.byThrottle) then\n    local longitudinalAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromThrottle(longitudinalEngineTags,axisCommandId.longitudinal)\n    Nav:setEngineForceCommand(longitudinalEngineTags, longitudinalAcceleration, keepCollinearity)\nelseif  (longitudinalCommandType == axisCommandType.byTargetSpeed) then\n    local longitudinalAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromTargetSpeed(axisCommandId.longitudinal)\n    autoNavigationEngineTags = autoNavigationEngineTags .. ' , ' .. longitudinalEngineTags\n    autoNavigationAcceleration = autoNavigationAcceleration + longitudinalAcceleration\n    if (Nav.axisCommandManager:getTargetSpeed(axisCommandId.longitudinal) == 0 or -- we want to stop\n        Nav.axisCommandManager:getCurrentToTargetDeltaSpeed(axisCommandId.longitudinal) < - Nav.axisCommandManager:getTargetSpeedCurrentStep(axisCommandId.longitudinal) * 0.5) -- if the longitudinal velocity would need some braking\n    then\n        autoNavigationUseBrake = true\n    end\n\nend\n\n-- Lateral Translation\nlocal lateralStrafeEngineTags = 'thrust analog lateral'\nlocal lateralCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.lateral)\nif (lateralCommandType == axisCommandType.byThrottle) then\n    local lateralStrafeAcceleration =  Nav.axisCommandManager:composeAxisAccelerationFromThrottle(lateralStrafeEngineTags,axisCommandId.lateral)\n    Nav:setEngineForceCommand(lateralStrafeEngineTags, lateralStrafeAcceleration, keepCollinearity)\nelseif  (lateralCommandType == axisCommandType.byTargetSpeed) then\n    local lateralAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromTargetSpeed(axisCommandId.lateral)\n    autoNavigationEngineTags = autoNavigationEngineTags .. ' , ' .. lateralStrafeEngineTags\n    autoNavigationAcceleration = autoNavigationAcceleration + lateralAcceleration\nend\n\n-- Vertical Translation\nlocal verticalStrafeEngineTags = 'thrust analog vertical'\nlocal verticalCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.vertical)\nif (verticalCommandType == axisCommandType.byThrottle) then\n    local verticalStrafeAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromThrottle(verticalStrafeEngineTags,axisCommandId.vertical)\n    Nav:setEngineForceCommand(verticalStrafeEngineTags, verticalStrafeAcceleration, keepCollinearity, 'airfoil', 'ground', '', tolerancePercentToSkipOtherPriorities)\nelseif  (verticalCommandType == axisCommandType.byTargetSpeed) then\n    local verticalAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromTargetSpeed(axisCommandId.vertical)\n    autoNavigationEngineTags = autoNavigationEngineTags .. ' , ' .. verticalStrafeEngineTags\n    autoNavigationAcceleration = autoNavigationAcceleration + verticalAcceleration\nend\n\n-- Auto Navigation (Cruise Control)\nif (autoNavigationAcceleration:len() > constants.epsilon) then\n    if (brakeInput ~= 0 or autoNavigationUseBrake or math.abs(constructVelocityDir:dot(constructForward)) < 0.95)  -- if the velocity is not properly aligned with the forward\n    then\n        autoNavigationEngineTags = autoNavigationEngineTags .. ', brake'\n    end\n    Nav:setEngineForceCommand(autoNavigationEngineTags, autoNavigationAcceleration, dontKeepCollinearity, '', '', '', tolerancePercentToSkipOtherPriorities)\nend\n\n-- Rockets\nNav:setBoosterCommand('rocket_engine')\n","filter":{"args":[],"signature":"flush()","slotKey":"-2"},"key":"30"},{"code":"pitchInput = pitchInput + 1","filter":{"args":[{"value":"forward"}],"signature":"actionStop(forward)","slotKey":"-2"},"key":"31"},{"code":"if Nav.control.isAnyHeadlightSwitchedOn() == 1 then\n    Nav.control.switchOffHeadlights()\nelse\n    Nav.control.switchOnHeadlights()\nend\n","filter":{"args":[{"value":"light"}],"signature":"actionStart(light)","slotKey":"-2"},"key":"32"},{"code":"pitchInput = pitchInput - 1","filter":{"args":[{"value":"forward"}],"signature":"actionStart(forward)","slotKey":"-2"},"key":"33"},{"code":"pitchInput = pitchInput + 1","filter":{"args":[{"value":"backward"}],"signature":"actionStart(backward)","slotKey":"-2"},"key":"34"},{"code":"pitchInput = pitchInput - 1","filter":{"args":[{"value":"backward"}],"signature":"actionStop(backward)","slotKey":"-2"},"key":"35"},{"code":"rollInput = rollInput - 1","filter":{"args":[{"value":"left"}],"signature":"actionStart(left)","slotKey":"-2"},"key":"36"},{"code":"rollInput = rollInput + 1","filter":{"args":[{"value":"left"}],"signature":"actionStop(left)","slotKey":"-2"},"key":"37"},{"code":"rollInput = rollInput + 1","filter":{"args":[{"value":"right"}],"signature":"actionStart(right)","slotKey":"-2"},"key":"38"},{"code":"rollInput = rollInput - 1","filter":{"args":[{"value":"right"}],"signature":"actionStop(right)","slotKey":"-2"},"key":"39"},{"code":"Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.lateral, 1.0)","filter":{"args":[{"value":"straferight"}],"signature":"actionStart(straferight)","slotKey":"-2"},"key":"40"},{"code":"Nav.axisCommandManager:updateCommandFromActionStop(axisCommandId.lateral, -1.0)","filter":{"args":[{"value":"straferight"}],"signature":"actionStop(straferight)","slotKey":"-2"},"key":"41"},{"code":"mpc.bti.target = (mpc.bti.target - 1 + mpc.bti.maxWaypoints - 1) % mpc.bti.maxWaypoints + 1","filter":{"args":[{"value":"lshift"}],"signature":"actionStart(action)","slotKey":"-2"},"key":"42"},{"code":"mpc.bti.target = (mpc.bti.target - 1 + mpc.bti.maxWaypoints + 1) % mpc.bti.maxWaypoints + 1","filter":{"args":[{"value":"lalt"}],"signature":"actionStart(action)","slotKey":"-2"},"key":"43"},{"code":"mpc.handbrake = not mpc.handbrake","filter":{"args":[{"value":"option1"}],"signature":"actionStart(action)","slotKey":"-2"},"key":"44"},{"code":"mpc.autobrake = not mpc.autobrake","filter":{"args":[{"value":"option2"}],"signature":"actionStart(action)","slotKey":"-2"},"key":"45"},{"code":"if lightSwitch then\n    lightSwitch.toggle()\n    mpc.lights = not mpc.lights\nend","filter":{"args":[{"value":"option3"}],"signature":"actionStart(action)","slotKey":"-2"},"key":"46"},{"code":"function requireSvgHelper()\n    local function isTable(t)   return type(t) == 'table'  end\n\n    local svg = {}\n    svg._fontsize = 20\n    svg._pad = 4\n    svg._tablepad = 30\n    svg._textColor = \"yellow\"\n    svg._displayKey = true\n    svg._displayTable = true\n\n    function svg.dump()\n        return svg.header .. svg.style .. \"</style><defs>\" .. svg.base .. \"</defs>\" .. svg.body .. svg.footer\n    end\n\n    function svg.toSVG(arr, x, ystart, settings, depth)\n        local svgtext = \"\"\n        ystart = ystart or 20\n        x = x or 25\n        settings = settings or {}\n        settings.maxDepth = settings.maxDepth or 99999\n        if (settings.displayKey == nil) then settings.displayKey = svg._displayKey end\n        if (settings.displayTable == nil) then settings.displayTable = svg._displayTable end\n        depth = depth or 0\n\n        local i = 0\n        local ii = 0\n        for k, v in pairs(arr) do\n            i = i + 1\n            if (depth == 0) then ii = ii + 1 end\n            local valueIsTable = isTable(v)\n            svgtext = svgtext .. string.format([[\n                <text x=\"%d\" y=\"%d\"\n                font-size=\"%dpx\" fill=\"%s\" stroke=\"black\" stroke-width=\"2\">\n                %s%s\n                </text>\n                ]], x + depth*svg._tablepad, (ystart + (i + ii - 1)*(svg._fontsize + svg._pad)),\n                svg._fontsize, svg._textColor,\n                settings.displayKey and (k..\" : \") or \"\", valueIsTable and \"{...}\" or v)\n            if (settings.displayTable and valueIsTable and (depth <= settings.maxDepth)) then\n                local svgtable, ret = svg.toSVG(v, x, (ystart + (i + ii)*(svg._fontsize + svg._pad)), settings, depth+1)\n                ii = ii + ret\n                svgtext = svgtext .. svgtable\n            end\n        end\n        return svgtext, i + ii\n    end\n\n    function svg.imageCut(path, imageSize, screenViewbox, svgViewbox) -- viewbox are rect: x y width height\n        return string.format([[\n            <svg x=\"%d\" y=\"%d\" width=\"%d\" height=\"%d\" preserveAspectRatio=\"none\"\n            viewBox=\"%d %d %d %d\"\n            xmlns=\"http://www.w3.org/2000/svg\" \n            xmlns:xlink=\"http://www.w3.org/1999/xlink\"> \n            <image width=\"%d\" height=\"%d\" xlink:href=\"%s\" />\n            </svg>]],\n            screenViewbox.x, screenViewbox.y, screenViewbox.width, screenViewbox.height,\n            svgViewbox.x, svgViewbox.y, svgViewbox.width, svgViewbox.height,\n            imageSize.x, imageSize.y, path)\n    end\n\n    svg.header = [[\n\n    <svg class=\"svg\"\n    width=\"1920\" height=\"1080\"\n    viewBox=\"0 0 1920 1080\"\n    xmlns=\"http://www.w3.org/2000/svg\" \n    xmlns:xlink=\"http://www.w3.org/1999/xlink\"> \n    <style>\n    .svg {\n    position:absolute;\n    left: 0;\n    top: 0;\n    height: 100vh;\n    width: 100vw;\n}\n    ]]\n    svg.style = [[]]\n    svg.base = [[]]\n    svg.footer = [[</svg>]]\n    svg.body = [[]]\n\n    return svg\nend","filter":{"args":[],"signature":"start()","slotKey":"-3"},"key":"47"},{"code":"-- BTI v1.1\nlocal function dhms(time, displayAll, sep)\n    displayAll = displayAll or false\n    sep = sep or {\"d\",\"h\",\"m\",\"s\"}\n    local dhmsValues = {86400, 3600, 60, 1}\n    local res = \"\"\n    for i, v in ipairs(dhmsValues) do\n        local r = math.floor(time / dhmsValues[i])\n        time = time % dhmsValues[i]\n        if displayAll or r ~= 0 then\n            res = res .. string.format([[%.2d%s]], r, sep[i])\n        end\n    end\n    return res ~= \"\" and res or (\"0\"..sep[4])\nend\n\nfunction requireBasicTravelInfos()\n    --[[\n    dependency: SvgHelper\n    \n    unit > start\n        svg = requireSvgHelper() -- or require(\"svghelper\")\n        bti = requireBasicTravelInfos()\n        system.showScreen(1)\n        unit.setTimer(\"eta\", 0.25)\n    unit > tick(eta)\n        svg.body = bti:getSvgcode()\n        system.setScreen(svg.dump())\n    system > actionStart(lshift)\n        bti.target = (bti.target - 1 + bti.maxWaypoints - 1) % bti.maxWaypoints + 1\n    system > actionStart(lalt)\n        bti.target = (bti.target - 1 + bti.maxWaypoints + 1) % bti.maxWaypoints + 1\n\n    ]]\n    \n    local bti = {}\n    bti.waypoints = {\n        {name=\"Alioth\", x=-8, y=-8, z=-126303},\n        {name=\"Madis\", x=17465536, y=22665536, z=-34464},\n        {name=\"Thades\", x=29165536, y=10865536, z=65536},\n        {name=\"Talemai\", x=-13234464, y=55765536, z=465536},\n        {name=\"Feli\", x=-43534464, y=22565536, z=-48934464},\n        {name=\"Sicari\", x=52765536, y=27165536, z=52065536},\n        {name=\"Sinnen\", x=58665536, y=29665536, z=58165536},\n        {name=\"Teoma\", x=80865536, y=54665536, z=-934464},\n        {name=\"Jago\", x=-94134464, y=12765536, z=-3634464},\n        {name=\"Symeon\", x=14165536, y=-85634464, z=-934464},\n        {name=\"Ion\", x=2865536, y=-99034464, z=-934464},\n        {name=\"Lacobus\", x=98865536, y=-13534464, z=-934464}\n    }\n    bti.maxWaypoints = 0\n    for _, v in ipairs(bti.waypoints) do\n        bti.maxWaypoints = bti.maxWaypoints + 1\n    end\n    bti.target = 1\n\n\n    function\tbti.travelInfos(target, shipPos, speed, mass, pos, fontsize)\n        fontsize = fontsize or 18\n        pos = pos and vec3(pos) or vec3(10, 30, 0)\n        local name = target.name or \"?\"\n        local dist = (shipPos - target):len()\n        local su = 200000\n        local t = 1000\n\n        local travel = {\n            atCurrentSpeed = math.floor(dist / speed),\n            atMaxSpeed = math.floor(dist / 8333),\n            warpCells = ((mass/t) * (dist/su) / 4000)\n        }\n\n        fontsize = fontsize or 20\n        local x = pos.x\n        local y = pos.y\n        local svgcode = string.format([[<g fill=\"%s\" font-size=\"%dpx\">]], \"#99ccff\", fontsize)\n        --title\n        svgcode = svgcode .. string.format([[\n            <text x=\"%d\" y=\"%d\" font-weight=\"bold\" text-decoration=\"underline\">Travel time to %s (%dsu) :</text>]],\n            x, y, target.name, math.ceil(dist/su))\n        --current speed\n        y = y + fontsize\n        svgcode = svgcode .. string.format([[\n            <text x=\"%d\" y=\"%d\">At current speed: %s</text>]],\n            x, y, travel.atCurrentSpeed == 1/0 and \"∞\" or dhms(travel.atCurrentSpeed))\n        --max speed\n        y = y + fontsize\n        svgcode = svgcode .. string.format([[\n            <text x=\"%d\" y=\"%d\">At max speed: %s</text>]],\n            x, y, dhms(travel.atMaxSpeed))\n        --warp cell\n        y = y + fontsize\n        svgcode = svgcode .. string.format([[\n            <text x=\"%d\" y=\"%d\">Warp cells for %dt : %s</text>]],\n            x, y, math.ceil(mass/t), math.ceil(travel.warpCells))\n\n        svgcode = svgcode .. [[</g>]]\n        return svgcode\n    end\n    \n    function\tbti:getSvgcode(pos)\n        local speed = vec3(core.getWorldVelocity()):len()\n        local selectedTarget = self.waypoints[self.target]\n        local shipPos = vec3(core.getConstructWorldPos())\n        local mass = core.getConstructMass()\n\n        return self.travelInfos(selectedTarget, shipPos, speed, mass, pos, 18)\n    end\n    \n    return bti\nend","filter":{"args":[],"signature":"start()","slotKey":"-3"},"key":"48"},{"code":"-- MPC v1.0\n--[[\n\n    alt : settings (vcursor)\n    option1 : toggle handbrake\n    option2 : toggle brakes\n    option3 : toggle lights\n    settings: toggle space brake safety (dep: BTI)\n\n    --[[\n\ntoggle: brake if <2su of target (BTI)\ndemarrage instant hover/booster\n\nbasic interface:\n    fuel tank : time to depletion\n\ttrottle -100 +100 % (+speed km/h  m/s)\n\thover/booster alt stab (api not working?)\n\nsettings:\n\tdisable vbooster on atmo\n--]]\n\nfunction    requireMinimalPilotingConfig(atmotanks, spacetanks)\n    local mpc = {\n        bti = requireBasicTravelInfos(),\n        piloting = {},\n        handbrake = false,\n        autobrake = false,\n        brakeAtRange = false, -- default 2su\n        lights = false,\n        vBoosters = true,\n        atmotanks = atmotanks,\n        spacetanks = spacetanks,\n        nitronMass = 4,\n        kergonMass = 6,\n        gearsThreshold = 40,\n    }\n\n    function\tmpc:initTanksData(\n            ContainerOptimization,\n            FuelTankOptimization,\n            AtmosphericFuelTankHandling,\n            SpaceFuelTankHandling)\n    \n        self.nitronMass = 4 * (1 - 0.05*(ContainerOptimization + FuelTankOptimization))\n        self.kergonMass = 6 * (1 - 0.05*(ContainerOptimization + FuelTankOptimization))\n        for _, t in pairs(self.atmotanks) do\n            t.volume = getTankMaxVolume(t, AtmosphericFuelTankHandling)\n            t.percent = getTankPercent(t, t.volume, self.nitronMass)\n        end\n        for _, t in pairs(self.spacetanks) do\n            t.volume = getTankMaxVolume(t, SpaceFuelTankHandling)\n            t.percent = getTankPercent(t, t.volume, self.kergonMass)\n        end\n    end\n\n    function    mpc:updateTanksPercent()\n        for _, t in pairs(self.atmotanks) do\n            t.percent = getTankPercent(t, t.volume, self.nitronMass)\n        end\n        for _, t in pairs(self.spacetanks) do\n            t.percent = getTankPercent(t, t.volume, self.kergonMass)\n        end\n    end\n    function    mpc:getSvgFuelGauge(pos, right2left)\n        pos = pos and vec3(pos) or vec3(10, 100, 0)\n        local r = 8\n        local spacing = math.ceil(r*3)\n        if right2left then spacing = -spacing end\n        local svgcode = \"\"\n        svgcode = svgcode .. [[\n            <g class=\"fuel\">\n            <g class=\"nitron\">\n        ]]\n        for i, t in pairs(self.atmotanks) do\n            svgcode = svgcode .. svgCircularGauge(t.percent, pos + i*vec3(spacing,0,0), r, \"gauge\", \"gauge-bg\")\n        end\n        svgcode = svgcode .. [[</g><g class=\"kergon\">]]\n        pos = pos + vec3(0, math.abs(spacing), 0)\n        for i, t in pairs(self.spacetanks) do\n            svgcode = svgcode .. svgCircularGauge(t.percent, pos + i*vec3(spacing,0,0), r, \"gauge\", \"gauge-bg\")\n        end\n        svgcode = svgcode .. [[</g></g>]]\n        return svgcode\n    end\n\n    function    mpc:updatePilotingInfos()\n        self.piloting.throttle = unit.getThrottle() --unit.getAxisCommandValue(0) * 100, -- Longitudinal = 0, lateral = 1, vertical = 2    //  unit.getThrottle()\n        self.piloting.surfaceStabilization = unit.computeGroundEngineAltitudeStabilizationCapabilities()[1]-- vec2 --getSurfaceEngineAltitudeStabilization() -- meter\n        self.piloting.telemeterRange = telemeter and telemeter.getDistance() or nil\n        self.piloting.gears = unit.isAnyLandingGearExtended()\n        --self.piloting.brakingPower = ??, -- done in flush\n    end\n    function    mpc:getSvgPilotingInfos(pos)\n        pos = pos and vec3(pos) or vec3(1675, 525, 0)\n        local fontsize = 14\n        local colorOn = \"#33cc33\"\n        local color = \"#99ccff\"\n        local svgcode = \"\"\n        svgcode = svgcode .. svgTextBG(\"Braking\", pos + vec3(0,-20,0), fontsize, (self.piloting.brakingPower > 0) and colorOn or color)\n        svgcode = svgcode .. svgTextBG(\"HandBrake\", pos + vec3(70,-20,0), fontsize, (self.handbrake) and colorOn or color)\n        svgcode = svgcode .. svgTextBG(\"AutoBrake\", pos + vec3(157,-20,0), fontsize, (self.autobrake) and colorOn or color)\n        svgcode = svgcode .. svgTextBG(\"Lights\", pos + vec3(157,-40,0), fontsize, (self.lights) and colorOn or color)\n        svgcode = svgcode .. svgTextBG(\"Gears\", pos + vec3(157,-60,0), fontsize, (self.piloting.gears == 1) and colorOn or color)\n\n        --brake calc\n        local brakeData = calcBrakeTimeAndDistance(core.getConstructMass(), vec3(core.getWorldVelocity()):len(), self.brakePower)\n        local text1 = math.ceil(brakeData.distance) / 1000 .. \"km \"\n        local text2 = \" |  \" .. dhms(brakeData.time)\n        svgcode = svgcode .. string.format([[\n            <g style=\"fill:%s;font-size:12;font-weight:bold;\">\n                <text x=\"%d\" y=\"%d\" text-anchor=\"middle\">Brake distance and time :</text>\n                <text x=\"%d\" y=\"%d\" text-anchor=\"end\">%s</text>\n                <text x=\"%d\" y=\"%d\" >%s</text>\n            </g>]],\n            color,\n            pos.x+120, pos.y+10,\n            pos.x+120, pos.y+25, text1,\n            pos.x+123, pos.y+25, text2)\n\n        --floor dist and stabilization height\n        local maxRange = 100 -- telemeter \n        local min = vec3(pos) + vec3(-15, 330, 0)\n        local direction = vec3(0, -300, 0)\n        local max = min + direction\n\n        local r = 0\n        local floor = 0\n        local floortext = \"\"\n        if self.piloting.telemeterRange then\n            r = math.ceil(self.piloting.telemeterRange)\n            r = r == -1 and 101 or r\n            floor = min + direction * (r / maxRange)\n            floor.x = math.ceil(floor.x)\n            floor.y = math.ceil(floor.y)\n            floortext = r == 101 and \"100+\" or r\n        else\n            floor = vec3(min)\n            floortext = \"?\"\n        end\n\n        local stab = min + direction * (self.piloting.surfaceStabilization / maxRange)\n        stab.x = math.ceil(stab.x)\n        stab.y = math.ceil(stab.y)\n        svgcode = svgcode .. string.format([[<line x1=\"%d\" y1=\"%d\" x2=\"%d\" y2=\"%d\" style=\"stroke:%s;stroke-width:2\" />\n            <g style=\"fill:%s;font-size:12;font-weight:bold;\">\n                <text x=\"%d\" y=\"%d\" text-anchor=\"end\">%s</text>\n                <text x=\"%d\" y=\"%d\">%s</text>\n            </g>]],\n            min.x, min.y, max.x, max.y, color,\n            color, floor.x, floor.y, floortext .. \" ►\",\n            stab.x, stab.y, (\"◄ \" .. math.ceil(self.piloting.surfaceStabilization)))\n\n            --[[\n        svgcode = svgcode .. svg.toSVG({\n            core.getMaxKinematicsParametersAlongAxis(),\n            unit.computeGroundEngineAltitudeStabilizationCapabilities(),\n        }, 20, 200)\n            --]]\n        return svgcode\n    end\n\n    function    mpc:automaticFeatures()\n        --gears\n        if self.piloting.telemeterRange then\n            if (self.piloting.telemeterRange > 0) and (self.piloting.telemeterRange <= self.gearsThreshold) then\n                if self.piloting.gears == 0 then unit.extendLandingGears() end\n            else\n                if self.piloting.gears == 1 then unit.retractLandingGears() end\n            end\n        end\n        -- on brake: red backlight\n    end\n\n    function\tmpc:getSvgcode()\n        local svgcode = \"\"\n        local atmolvls = {}\n        local spacelvls = {}\n        for _, t in pairs(self.atmotanks) do\n            table.insert(atmolvls, t.percent)\n        end\n        for _, t in pairs(self.spacetanks) do\n            table.insert(spacelvls, t.percent)\n        end\n        svgcode = svgcode .. self.bti:getSvgcode()\n        svgcode = svgcode .. self:getSvgFuelGauge(vec3(1800, 1030, 0), true) -- true = right2left\n        svgcode = svgcode .. self:getSvgPilotingInfos()\n\n  --  svg.body = svg.body .. svg.toSVG({displayedMenu}, 900, 30, {maxDepth=1})\n        return svgcode\n    end\n\n\n\n    return mpc\nend\n\n--[=[\n    Manual install on the seat controller after reloading a default configuration for flying contruct:\n        links (element : slot name) (* are optional):\n            * telemeter : telemeter \n            * lightSwitch : manual switch (with relay(s) to all lights)\n    \n        system\n            {...}\n        unit\n            {...}\n        library\n            {...}\n            svghelper\n                {...}\n            BTI\n                {...}\n\n--]=]\n","filter":{"args":[],"signature":"start()","slotKey":"-3"},"key":"49"},{"code":"-- util\nfunction\tgetTankMaxVolume(tank, talentlvl)\n    local defaultTanksMass = {35.03, 182.67, 988.67, 5480} -- xs, s, m, l\n    local defaultTanksVolumes= {100, 400, 1600, 12800} -- xs, s, m, l\n    local mass = tank.getSelfMass()\n    local vol = 0\n    for i, m in pairs(defaultTanksMass) do\n        if mass == m then\n            vol = defaultTanksVolumes[i] * (1 + 0.20*talentlvl) -- 20% bonus volume / lvl\n            break\n        end\n    end\n    return math.ceil(vol)\nend\n\nfunction\tgetTankPercent(tank, volume, fuelMassL)\n    local mm = volume * fuelMassL\n    local m = tank.getItemsMass()\n    return math.ceil(m / mm * 100)\nend\n\nfunction\tcalcBrakeTimeAndDistance(mass, speed, brakePower)\n    mass = mass / 1 -- convert to kg\n    local c = 8333.34\n    local v = speed\n    local ds = (c*c*mass) / (brakePower) * (1 - math.sqrt(1 - ((speed*speed)/(c*c))))\n    local t = mass * (c/brakePower) * math.asin(v/c)\n    return {distance = ds, time = t}\nend\n\nfunction dhms(time, displayAll, sep)\n    displayAll = displayAll or false\n    sep = sep or {\"d\",\"h\",\"m\",\"s\"}\n    local dhmsValues = {86400, 3600, 60, 1}\n    local res = \"\"\n    for i, v in ipairs(dhmsValues) do\n        local r = math.floor(time / dhmsValues[i])\n        time = time % dhmsValues[i]\n        if displayAll or r ~= 0 then\n            res = res .. string.format([[%.2d%s]], r, sep[i])\n        end\n    end\n    return res ~= \"\" and res or (\"0\"..sep[4])\nend","filter":{"args":[],"signature":"start()","slotKey":"-3"},"key":"50"}],"methods":[],"events":[]}
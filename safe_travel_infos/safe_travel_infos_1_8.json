{"slots":{"0":{"name":"core","type":{"events":[],"methods":[]}},"1":{"name":"screen1","type":{"events":[],"methods":[]}},"2":{"name":"screen2","type":{"events":[],"methods":[]}},"3":{"name":"slot4","type":{"events":[],"methods":[]}},"4":{"name":"slot5","type":{"events":[],"methods":[]}},"5":{"name":"slot6","type":{"events":[],"methods":[]}},"6":{"name":"slot7","type":{"events":[],"methods":[]}},"7":{"name":"slot8","type":{"events":[],"methods":[]}},"8":{"name":"slot9","type":{"events":[],"methods":[]}},"9":{"name":"slot10","type":{"events":[],"methods":[]}},"-1":{"name":"unit","type":{"events":[],"methods":[]}},"-2":{"name":"system","type":{"events":[],"methods":[]}},"-3":{"name":"library","type":{"events":[],"methods":[]}}},"handlers":[{"code":"--print(\"mouse down : \" .. math.floor(x*g.w) .. \" \" .. math.floor(y*g.h))\nselector:tryClick(math.floor(x*g.w), math.floor(y*g.h))","filter":{"args":[{"variable":"*"},{"variable":"*"}],"signature":"mouseDown(x,y)","slotKey":"1"},"key":"0"},{"code":"--[[\n    Safe Travel Infos v1.8\n\n    links order:\n        1. core\n        2. screen\n        3. screen 2 (optionnal)\n]]\nsystem.showScreen(1)\nsystem.setScreen([[<svg class=\"svg\" viewBox=\"0 0 1920 1080\" preserveAspectRatio=\"none\"\nxmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\">\n<style>\n    .svg {position:absolute;left:0;top:0;height:100vh;width:100vw;</style>\n<text x=\"1917\" y=\"1077\" font-size=\"9\" fill=\"#99ccff\" text-anchor=\"end\">STI v1.8</text>\n</svg>]])\n\nunit.hide()\nprint = system.print\nlocal main_color = \"#99ccff\"\nlocal screen_refresh = 5 --export: the screen blinks at each refresh, low values are not recommanded\nlocal d = 34\nlocal w = 1920\nlocal h = 1080 + d*2\ndebug = {show=false}\ng = {\n    w = w,\n    h = h,\n    cursorPos = {x=0,y=0},\n    needRefresh = true,\n}\n\n---------------------\n--dep\natlas = require(\"atlas\")\nRect = requireRect()\nsvg = requireSvgHelper()\nsvg.header = string.format([[\n    <svg x=\"0\" y=\"%d\" width=\"%d\" height=\"%d\" viewBox=\"0 0 %d %d\" preserveAspectRatio=\"none\"\n        xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\">]],\n    -d, w, h,  w, h)\nsvg._fontsize = 40\nButton, ButtonGroup, VirtualCursor = requireButton()\nlocal hint_fontsize = 25 --export: fontsize of the hints for buttons\nButton.hintFontsizeMin = hint_fontsize\nButton._color = main_color\nButton:updateSvghelper(svg)\n\n---------------------\n--sti\nsti = requireSafeTravelInfos()\nsti:initBti(requireBasicTravelInfos())\nsti:initHeightsGrid(vec3(math.floor(g.w*0.57),30,0)) -- to do after initBti()\nsti:setTextColor(main_color)\nsti.bti.fontsize = 50\nsti:updateSvghelper(svg)\nsti.atlas = requireAtlasCompact()\ndisplay_more_trajectorys = false --export: ! higher CPU cost: forward and velocity trajectorys\nsti.displayMoreTrajectorys = display_more_trajectorys\n\n\nlocal experimental_features = false --export: Simulation (Option 7)\nsti.experimental = experimental_features\n\n---------------------\n--planet selector and simulation\nselector = requirePlanetSelector()\nselector:initPlanets(sti.bti.waypoints)\nselector.color = main_color\nlocal simulation_fps = 20 --export: put a lower value if the screen blinks too much\nlocal simulation_duration = 10 --export: in second\nselector.simulation.deltaTime = 1/simulation_fps\nselector.simulation.duration = simulation_duration\n---------------------\n--start\n\nselector.planetSelectionOrigin[1]:_click()\nselector.planetSelectionDestination[2]:_click()\n\nscreen1.activate()\nif screen2 then screen2.activate() end\nhud = false\nunit.setTimer(\"tv\", 0.05)\nunit.setTimer(\"refresh\", screen_refresh)","filter":{"args":[],"signature":"start()","slotKey":"-1"},"key":"1"},{"code":"screen1.deactivate()\nif screen2 then screen2.deactivate() end","filter":{"args":[],"signature":"stop()","slotKey":"-1"},"key":"2"},{"code":"if g.needRefresh then\n    if screen1 then\n        svg.body = \"\"\n        svg.body = svg.body .. string.format([[\n            <rect x=\"0\" y=\"0\" width=\"%d\" height=\"%d\" fill=\"black\" />]], g.w, g.h)\n        svg.body = svg.body .. sti:getSvgcode(selector.simulation.running and sti.shipPos) .. selector:getSvgcode()\n        svg.body = svg.body .. sti:getLateSvgcode() .. selector:getLateSvgcode()\n        screen1.setSVG(svg.dump())\n    end\n    if screen2 then\n        screen2.setHTML(sti:getHtmlCompleteGrid())\n    end\n    if hud then\n        svg.body = \"\"\n        svg.body = svg.body .. sti:getSvgGrid()\n        system.setScreen(svg.dump())\n    end\n    if debug.show then\n        print(\"debug ON\")\n        svg.body = \"\"\n        local old = svg._fontsize\n        svg._fontsize = 17\n        svg.body = svg.body .. [[\n        <rect x=\"1200\" y=\"0\" width=\"1920\" height=\"1080\" opacity=\"0.75\" fill=\"#111144\" />]]\n        \n        svg.body = svg.body .. svg.toSVG({debug, simu=selector.simulation}, 1200, 25)\n        system.setScreen(svg.dump())\n        svg._fontsize = old\n    end\n    g.needRefresh = false\nelse\nend","filter":{"args":[{"value":"tv"}],"signature":"tick(timerId)","slotKey":"-1"},"key":"3"},{"code":"g.needRefresh = true","filter":{"args":[{"value":"refresh"}],"signature":"tick(timerId)","slotKey":"-1"},"key":"4"},{"code":"selector:runSimulationStep()\ng.needRefresh = true","filter":{"args":[{"value":"simulation"}],"signature":"tick(timerId)","slotKey":"-1"},"key":"5"},{"code":"local pos = {\n    x = math.floor(screen1.getMouseX()*g.w),\n    y = math.floor(screen1.getMouseY()*g.h)\n}\nif (pos.x ~= g.cursorPos.x) or (pos.y ~= g.cursorPos.y) then\n    g.cursorPos = pos\n    selector:update(g.cursorPos)\n    sti:updateGridButtonsStates(g.cursorPos)\nend\n","filter":{"args":[],"signature":"update()","slotKey":"-2"},"key":"6"},{"code":"if sti.experimental then selector:toggleSimulation() end","filter":{"args":[{"value":"option7"}],"signature":"actionStart(action)","slotKey":"-2"},"key":"7"},{"code":"--[[\n    Safe Travel Infos v1.8\n\n    links order:\n        1. core\n        2. screen\n        3. screen 2 (optionnal)\n\n    dep:\n        svghelper\n        Basic Travel Infos\n        Button\n\n    can do: for the 3 trajectorys: display a colored line with intersections with the 66 pipes (yellow/orange/red status)\n]]\nlocal min, max, floor, sqrt, abs = math.min, math.max, math.floor, math.sqrt, math.abs\nlocal su = 200000\nlocal overshootRatio = 1.3\nlocal function roundStr(num, numDecimalPlaces)\n    return string.format(\"%.\" .. (numDecimalPlaces or 0) .. \"f\", num)\nend\nlocal function fancy_sukm(distance, thresholds)\n    thresholds = thresholds or {km=200000, m=10000}\n    --display in su/km/m depending on its distance\n    if (distance < thresholds.m) then\n        distance = roundStr(distance, 0) .. \" m\"\n    elseif (distance < thresholds.km) then\n        distance = roundStr(distance / 1000, 1) .. \" km\"\n    else\n        distance = roundStr(distance / 200000, 2) .. \" su\"\n    end\n    return distance\nend\nlocal function round(num, numDecimalPlaces)\n    local mult = 10^(numDecimalPlaces or 0)\n    return floor(num * mult + 0.5) / mult\nend\nlocal function interSpherePlan(sphere, plan)\n    local circle = {}\n    circle.center = sphere.center:project_on_plane(plan)\n    circle.r = 0\n    local translation = circle.center - sphere.center\n    local dist2 = translation:len2()\n    local r2 = sphere.r*sphere.r\n    if dist2 < r2 then\n        circle.r = sqrt(r2 - dist2)\n    end\n    return circle\nend\nlocal function convertPointInCoosys(coosys, point)\n    local newPoint = point - coosys.origin\n    return vec3{\n        x = newPoint:dot(coosys.x),\n        y = newPoint:dot(coosys.y),\n        z = newPoint:dot(coosys.z),\n    }\nend\n\nlocal svglib = {\n    pvp = [[\n        <svg id=\"pvp\" x=\"0\" y=\"0\" width=\"250\" height=\"250\"\n        xmlns=\"http://www.w3.org/2000/svg\"\n        xmlns:xlink=\"http://www.w3.org/1999/xlink\" \n             viewBox=\"0 4 22.778 22.778\" >\n            <g>\n                <polygon points=\"17.931,15.433 18.83,10.328 14.412,12.625 12.438,8.625 10.468,12.616 6.05,10.269 \n                    6.912,15.437 2.098,16.137 4.685,18.66 5.68,18.66 3.59,16.622 7.713,16.021 6.967,11.542 10.773,13.566 12.438,10.193 \n                    14.103,13.568 17.903,11.593 17.122,16.017 21.285,16.622 19.196,18.66 20.19,18.66 22.778,16.137 \t\t\"/>\n                <polygon points=\"16.322,16.545 16.95,12.977 13.84,14.594 12.427,11.732 11.02,14.583 7.917,12.935 \n                    8.518,16.548 5.119,17.042 6.777,18.66 8.766,18.66 8.102,18.012 10.121,17.718 9.748,15.481 11.631,16.483 12.427,14.87 \n                    13.222,16.479 15.095,15.507 14.704,17.714 16.752,18.012 16.088,18.66 18.076,18.66 19.737,17.042 \t\t\"/>\n                <path d=\"M12.438,17.909c-0.503,0-0.91,0.408-0.91,0.911h1.822C13.35,18.316,12.942,17.909,12.438,17.909z\"\n                    />\n                <polygon points=\"17.915,3.958 14.888,10.515 15.382,10.72 \"/>\n                <polygon points=\"5.694,14.399 0,9.958 5.348,14.809 \"/>\n                <polygon points=\"21.633,11.866 19.072,14.083 19.453,14.458 \"/>\n                <polygon points=\"10.303,10.5 8.866,7.43 9.801,10.688 \"/>\n                <text x=\"12.2\" y=\"25.5\" font-size=\"8\" text-anchor=\"middle\">PVP</text>\n            </g>\n        </svg>\n    ]],\n    safe = [[\n        <svg id=\"safe\" x=\"0\" y=\"0\" width=\"160\" height=\"160\"\n        xmlns=\"http://www.w3.org/2000/svg\"\n        xmlns:xlink=\"http://www.w3.org/1999/xlink\"\n             viewBox=\"0 0 32 32\" >\n             <path d=\"M29.6,5.2C29.3,5,29,4.9,28.7,5.1c-4.3,1.4-8.7,0.3-12-2.8c-0.4-0.4-1-0.4-1.4,0c-3.3,3.1-7.7,4.2-12,2.8\n            C3,4.9,2.7,5,2.4,5.2S2,5.7,2,6c0,15.7,6.9,20.9,13.6,23.9C15.7,30,15.9,30,16,30s0.3,0,0.4-0.1C23.1,26.9,30,21.7,30,6\n            C30,5.7,29.8,5.4,29.6,5.2z\"/>\n        </svg>\n    ]]\n}\nlocal image_links = {\n    Generic_Moon = \"assets.prod.novaquark.com/20368/f410e727-9d4d-4eab-98bf-22994b3fbdcf.png\",\n    Sun = \"assets.prod.novaquark.com/20368/0936494e-9b3d-4d60-9ea0-d93a3f3e29cd.png\",\n    Alioth = \"assets.prod.novaquark.com/20368/954f3adb-3369-4ea9-854d-a14606334152.png\",\n    Alioth_bis = \"assets.prod.novaquark.com/20368/b83225ed-fb96-404c-8c91-86ac15dfbbec.png\",\n    Sanctuary = \"assets.prod.novaquark.com/20368/1a70dbff-24bc-44cb-905c-6d375d9613b8.png\",\n    Feli = \"assets.prod.novaquark.com/20368/da91066c-b3fd-41f4-8c01-26131b0a7841.png\",\n    Ion = \"assets.prod.novaquark.com/20368/91d10712-dc51-4b73-9fc0-6f07d96605a6.png\",\n    Madis = \"assets.prod.novaquark.com/20368/46d57ef4-40ee-46ca-8cc5-5aee1504bbfe.png\",\n    Jago = \"assets.prod.novaquark.com/20368/7fca8389-6b70-4198-a9c3-4875d15edb38.png\",\n    Lacobus = \"assets.prod.novaquark.com/20368/cb67a6a4-933c-4688-a637-898c89eb5b94.png\",\n    Sicari = \"assets.prod.novaquark.com/20368/f6e2f801-075f-4ccd-ab94-46d060517e8f.png\",\n    Sinnen = \"assets.prod.novaquark.com/20368/54a99084-7c2b-461b-ab1f-ae4229b3b821.png\",\n    Symeon = \"assets.prod.novaquark.com/20368/97940324-f194-4e03-808d-d71733ad545a.png\",\n    Talemai = \"assets.prod.novaquark.com/20368/f68628d9-3245-4d76-968e-ad9c63a19c19.png\",\n    Teoma = \"assets.prod.novaquark.com/20368/5a01dd8c-3cf8-4151-99a2-83b22f1e7249.png\",\n    Thades = \"assets.prod.novaquark.com/20368/59f997a2-bcca-45cf-aa35-26e0e41ed5c1.png\",\n}\n\nfunction    requireSafeTravelInfos()\n    local sti = {}\n    sti.__index = sti\n    --[[\n        todo:\n        ship trajectory simulation (screen 3?):\n            slider for the desto dist , or the remaining dist in the ship trajectory until it hit the destination wall\n            autoplay, repeat\n        detect if parabol trajectory is in the middle of another travel route\n            give the best parabol route depending of the angle, with a set desto point\n    ]]\n    sti.experimental = false\n    sti.displayMoreTrajectorys = false\n    sti.color = \"white\"\n    sti.dangerZonesHeights = {\n        2*su, -- the detection range of a space radar, 100% sure to be caught by a scout warping\n        4*su, -- an arbitrary margin\n        6*su, -- another one \n    }\n    sti.dangerZoneScreenHeight = 250 --px\n    sti.dangerZonesColors = {\"#ff4d4d\", \"#ff8533\", \"#ffff66\"}\n    sti.planetaryProtection = 2.5*su\n    sti.bti = nil\n    sti.origin = 1\n    sti.destination = 2\n    sti.safeZone = { -- a sphere\n        center = vec3(13771471, 7435803, -128971), -- from Archaegeo\n        r = 18000000, -- 90su\n    }\n    sti.shipPos = vec3(core.getConstructWorldPos())\n\n    function    sti:setTextColor(color)\n        if type(color) == \"string\" then\n            self.color = color\n            self.bti.color = color\n        else\n            system.print(\"Error: wrong type for argument #1 of sti:setTextColor(color), string required\")\n        end\n    end\n    function    sti:initBti(bti)\n        self.bti = bti\n        for k, v in pairs(self.bti.waypoints) do\n            v.image = image_links[v.name]\n        end\n    end\n    function    sti:updateSvghelper(svgh)\n        svgh.style = svgh.style .. [[text {font-family:sans-serif;}]]\n        for k, v in pairs(svglib) do\n            svgh.base = svgh.base .. v\n        end\n        svgh.base = svgh.base .. string.format([[\n            <linearGradient  id=\"danger\" x1=\"0%%\" x2=\"0%%\" y1=\"0%%\" y2=\"100%%\">\n            <stop offset=\"5%%\" stop-color=\"none\" stop-opacity=\"0\"/>\n            <stop offset=\"10%%\" stop-color=\"%s\" stop-opacity=\"1\"/>\n            <stop offset=\"30%%\" stop-color=\"%s\" stop-opacity=\"1\"/>\n            <stop offset=\"40%%\" stop-color=\"%s\" stop-opacity=\"1\"/>\n            <stop offset=\"60%%\" stop-color=\"%s\" stop-opacity=\"1\"/>\n            <stop offset=\"70%%\" stop-color=\"%s\" stop-opacity=\"1\"/>\n            <stop offset=\"90%%\" stop-color=\"%s\" stop-opacity=\"1\"/>\n            <stop offset=\"95%%\" stop-color=\"none\" stop-opacity=\"0\"/>\n            <stop offset=\"100%%\" stop-color=\"none\" stop-opacity=\"0\" />\n            </linearGradient>]],\n            self.dangerZonesColors[3],\n            self.dangerZonesColors[2],\n            self.dangerZonesColors[1],\n            self.dangerZonesColors[1],\n            \"black\",\n            \"black\")\n            -- self.dangerZonesColors[2],\n            -- self.dangerZonesColors[3])\n        svgh.base = svgh.base .. string.format([[\n            <linearGradient  id=\"half-danger\" x1=\"0%%\" x2=\"0%%\" y1=\"0%%\" y2=\"100%%\">\n            <stop offset=\"10%%\" stop-color=\"none\" stop-opacity=\"1\"/>\n            <stop offset=\"20%%\" stop-color=\"%s\" stop-opacity=\"1\"/>\n            <stop offset=\"70%%\" stop-color=\"%s\" stop-opacity=\"1\"/>\n            <stop offset=\"90%%\" stop-color=\"%s\" stop-opacity=\"1\"/>\n            <stop offset=\"100%%\" stop-color=\"%s\" stop-opacity=\"1\"/>\n            </linearGradient>]],\n            self.dangerZonesColors[3],\n            self.dangerZonesColors[2],\n            self.dangerZonesColors[1],\n            self.dangerZonesColors[1])\n        svgh.base = svgh.base .. string.format([[\n            <linearGradient  id=\"black-topdown\" x1=\"0%%\" x2=\"0%%\" y1=\"0%%\" y2=\"100%%\">\n            <stop offset=\"0%%\" stop-color=\"none\" stop-opacity=\"1\"/>\n            <stop offset=\"80%%\" stop-color=\"%s\" stop-opacity=\"1\"/>\n            <stop offset=\"100%%\" stop-color=\"none\" stop-opacity=\"0\" />\n            </linearGradient>]], \"none\")\n        svgh.base = svgh.base .. string.format([[\n            <linearGradient  id=\"black-leftright\" x1=\"0%%\" x2=\"100%%\" y1=\"0%%\" y2=\"0%%\">\n            <stop offset=\"0%%\" stop-color=\"none\" stop-opacity=\"1\"/>\n            <stop offset=\"15%%\" stop-color=\"%s\" stop-opacity=\"1\"/>\n            <stop offset=\"100%%\" stop-color=\"none\" stop-opacity=\"0.35\" />\n            </linearGradient>]], \"none\")\n        svgh.base = svgh.base .. string.format([[\n            <linearGradient  id=\"black-rightleft\" x1=\"100%%\" x2=\"0%%\" y1=\"0%%\" y2=\"0%%\">\n            <stop offset=\"0%%\" stop-color=\"none\" stop-opacity=\"1\"/>\n            <stop offset=\"15%%\" stop-color=\"%s\" stop-opacity=\"1\"/>\n            <stop offset=\"100%%\" stop-color=\"none\" stop-opacity=\"0.35\" />\n            </linearGradient>]], \"none\")\n    end\n\n    function    sti:calculateKinematics(x1, x2, shipPos, velocityVec, forwardVec)\n        local k = {}\n        k.shipPos = vec3(shipPos)\n        k.velocityVec = vec3(velocityVec):normalize_inplace()\n        k.forwardVec = vec3(forwardVec):normalize_inplace()\n\n        k.origin = vec3(self.bti.waypoints[self.origin])\n        k.destination = vec3(self.bti.waypoints[self.destination])\n        k.shipVec = k.shipPos - k.origin\n        k.travelVec = k.destination - k.origin\n        k.travelDist = k.travelVec:len()\n        k.progressVec = k.shipVec:project_on(k.travelVec) -- progressVec on the travelVec\n        k.sign = (k.progressVec:dot(k.travelVec) > 0) and 1 or -1 \n        k.progressRatio = k.progressVec:len() / k.travelDist * k.sign --travel scale, can be used to determine if the ship is before/withing/after the travelVec\n        k.progressPos = k.origin + k.progressVec\n        k.shipHeightVec = k.shipPos - k.progressPos\n        k.shipHeight = k.shipHeightVec:len()\n        k.directTrajectoryVec = k.destination - k.shipPos -- gray doted line\n        k.directTrajectoryLen = k.directTrajectoryVec:len()\n        k.simulationLen = k.directTrajectoryLen * overshootRatio\n        k.velocityTrajectoryVec = k.velocityVec * k.simulationLen -- purple doted line\n        k.velocityTrajectoryEnd = k.shipPos + k.velocityTrajectoryVec\n        k.forwardTrajectoryVec = k.forwardVec * k.simulationLen -- greenish doted line\n        k.forwardTrajectoryEnd = k.shipPos + k.forwardTrajectoryVec\n\n        k.dangerDist = k.directTrajectoryLen\n        if k.shipHeight > self.dangerZonesHeights[1] then\n            k.dangerDist = k.dangerDist * self.dangerZonesHeights[1] / k.shipHeight -- thales\n        end\n        k.dangerDist = max(0, k.dangerDist - 2.5*su) -- minus planetery protection radius\n\n        --screen pov\n        k.warpLineScreenLen = x2 - x1\n        k.scale = {x = k.travelDist / k.warpLineScreenLen, y = self.dangerZonesHeights[3] / self.dangerZoneScreenHeight}\n        k.coosys = {\n            origin = k.origin,\n            x = k.travelVec:normalize(),\n            y = k.shipHeightVec:normalize(),\n        }\n        k.coosys.z = (k.coosys.x:cross(k.coosys.y)):normalize()\n        k.safeZoneCircle = interSpherePlan({center=self.safeZone.center - k.coosys.origin, r=self.safeZone.r}, k.coosys.z)-- relative to the origin of the coosys\n        self.kinematics = k\n    end\n    function    sti.getHeight(shipPos, origin, destination)\n        local travel = destination - origin\n        local floorVec = (shipPos - origin):project_on(travel)\n        local floorPos = origin + floorVec\n        local heightVec = shipPos - floorPos\n        return heightVec:len(), heightVec\n    end\n    function    sti:getSvgDangerZones(ypos, x1, x2)\n        local svgcode = \"\"\n        --gradient zones\n        svgcode = svgcode .. string.format([[\n            <rect x=\"%d\" y=\"%d\" rx=\"%d\" ry=\"%d\"\n            width=\"%d\" height=\"%d\" fill=\"url(#danger)\" />]],\n            x1-5, ypos-self.dangerZoneScreenHeight, 50, self.dangerZoneScreenHeight,\n            x2-x1+10, self.dangerZoneScreenHeight*2)\n        --warp tunnel (flashy red)\n        svgcode = svgcode .. string.format([[\n            <line x1=\"%d\" y1=\"%d\" x2=\"%d\" y2=\"%d\" stroke=\"#cc0000\" stroke-width=\"7\" />]],\n            x1, ypos, x2, ypos)\n        --warp tunnel text\n        svgcode = svgcode .. string.format([[\n            <text x=\"%d\" y=\"%d\" font-size=\"%d\" fill=\"#660000\" text-anchor=\"middle\">warp tunnel</text>]],\n            (x1+x2)/2, ypos+25, 20)\n        return svgcode\n    end\n    function    sti:getSvgTrajectorys(ypos, x1, x2)\n        -- higher CPU usage: move computing in a tick with a rate of 1/maxPoints of the main refresh \n        local k = self.kinematics\n        --settings\n        local maxPoints = 10\n        local step = k.directTrajectoryLen / maxPoints * overshootRatio\n        local colors = {\"darkgray\", \"purple\", \"green\"}\n        local trajectorys = {k.directTrajectoryVec:normalize(), k.velocityVec, k.forwardVec}\n\n        local legend = vec3(300, ypos + 175+45, 0)\n        local svgcode = \"\"\n        svgcode = svgcode .. string.format([[\n            <line x1=\"%d\" y1=\"%d\" x2=\"%d\" y2=\"%d\" stroke=\"%s\" stroke-width=\"6\" stroke-dasharray=\"12\" />\n            <line x1=\"%d\" y1=\"%d\" x2=\"%d\" y2=\"%d\" stroke=\"%s\" stroke-width=\"6\" stroke-dasharray=\"12\" />\n            <g font-size=\"36\" fill=\"%s\">\n            <text x=\"%d\" y=\"%d\">velocity trajectory</text>\n            <text x=\"%d\" y=\"%d\">forward trajectory</text></g>]],\n            legend.x, legend.y-17, legend.x+90, legend.y-17, colors[2],\n            legend.x, legend.y-17+45, legend.x+90, legend.y-17+45, colors[3],\n            self.color,\n            legend.x+110, legend.y,\n            legend.x+110, legend.y+45)\n            \n        for t=2, 3, 1 do --skip trajectory 1 (direct)\n            svgcode = svgcode .. string.format([[<polyline style=\"fill:none;stroke:%s;stroke-width:6;stroke-dasharray:12;\" points=\"]], colors[t])\n            local screenPoints = {}\n            for p=0, maxPoints, 1 do\n                local pos = k.shipPos + trajectorys[t] * p * step\n                local posVec = pos - k.origin\n                local progressVec = posVec:project_on(k.travelVec) -- progressVec on the travelVec\n                local progressPos = k.origin + progressVec\n                local shipHeightVec = pos - progressPos\n                local coosys = {\n                    origin = k.origin,\n                    x = k.travelVec:normalize(),\n                    y = shipHeightVec:normalize(),\n                }\n                coosys.z = (coosys.x:cross(coosys.y)):normalize()\n                local newPos = convertPointInCoosys(coosys, pos)\n                svgcode = svgcode .. string.format([[%d,%d ]], floor(x1+newPos.x/k.scale.x), floor(ypos-newPos.y/k.scale.y))\n            end\n            svgcode = svgcode .. [[\" />]]\n        end\n        return svgcode\n    end\n    function    sti:getSvgPlanetZones(ypos, x1, x2)\n        local svgcode = \"\"\n        local planetsize = {width=300, height=300}\n        local offsetX = 100\n        \n        --planetary protection\n        -- svgcode = svgcode .. string.format([[\n        --     <circle cx=\"%d\" cy=\"%d\" r=\"%d\" fill=\"black\" />\n        --     <circle cx=\"%d\" cy=\"%d\" r=\"%d\" fill=\"black\" />\n        -- ]], offsetX, floor(ypos),  floor(planetsize.width),\n        --     g.w-offsetX, floor(ypos),  floor(planetsize.width))\n\n        --image\n        if true then\n            if not selector.simulation.running then\n                local pcoef = 1.35\n                local imageSize = {width=512,height=512}\n                local svgViewbox = {x=0, y=0, width=512, height=512}\n                local originViewbox = {}\n                local destinationViewbox = {}\n                local c = (sti.origin == 3 and 2 or 1) * pcoef\n                originViewbox.x = floor(0+offsetX-planetsize.width/2 * c)\n                originViewbox.y = floor(ypos-planetsize.height/2 * c)\n                originViewbox.width = planetsize.width * c\n                originViewbox.height = planetsize.height * c\n                c = (sti.destination == 3 and 2 or 1) * pcoef\n                destinationViewbox.x = floor(g.w-offsetX-planetsize.width/2 * c)\n                destinationViewbox.y = floor(ypos-planetsize.height/2 * c)\n                destinationViewbox.width = planetsize.width * c\n                destinationViewbox.height = planetsize.height * c\n\n                --resized for bg\n                if true then\n                    c = (sti.origin == 3 and 1.5 or 1)\n                    originViewbox.width = floor(g.w * 0.4 * c)\n                    originViewbox.height = floor(g.w * 0.4 * c)\n                    originViewbox.x = x1 - originViewbox.width/2\n                    originViewbox.y = ypos - originViewbox.height/2\n                    originViewbox.y = floor(originViewbox.height*0.25) - originViewbox.height/2\n                    c = (sti.destination == 3 and 1.5 or 1)\n                    destinationViewbox.width = floor(g.w * 0.4 * c)\n                    destinationViewbox.height = floor(g.w * 0.4 * c)\n                    destinationViewbox.x = x2 - destinationViewbox.width/2\n                    destinationViewbox.y = ypos - destinationViewbox.height/2\n                    destinationViewbox.y = floor(destinationViewbox.height*0.25) - destinationViewbox.height/2\n                end\n                --end\n                svgcode = svgcode .. [[<g opacity=\"0.70\">]]\n                svgcode = svgcode .. svg.imageCut(self.bti.waypoints[self.origin].image, imageSize, originViewbox, svgViewbox)\n                svgcode = svgcode .. svg.imageCut(self.bti.waypoints[self.destination].image, imageSize, destinationViewbox, svgViewbox)\n                svgcode = svgcode .. [[</g>]]\n            end\n        else -- or simple circle\n            svgcode = svgcode .. string.format([[\n                <circle cx=\"%d\" cy=\"%d\" r=\"%d\" fill=\"%s\" />\n                <circle cx=\"%d\" cy=\"%d\" r=\"%d\" fill=\"%s\" />\n            ]], offsetX, floor(ypos),  floor(planetsize.width/2), \"#734d26\",\n                g.w-offsetX, floor(ypos),  floor(planetsize.width/2), \"#734d26\")\n        end\n\n        -- local pvpOrigin = offsetX + planetsize.width\n        -- local pvpDestination = g.w - offsetX - planetsize.width\n        return svgcode--, pvpOrigin, pvpDestination\n    end\n    function    sti:getSvgDangerZoneForDirectTrajectory(ypos, shipHeight, shipPos, destination)\n        local dangerDist = vec3(destination - shipPos):len()\n        if shipHeight > self.dangerZonesHeights[1] then\n            dangerDist = dangerDist * self.dangerZonesHeights[1] / shipHeight -- thales\n        end\n        dangerDist = max(0, dangerDist / su - 2.5)\n        local screenPos = vec3(300, ypos + 175, 0)\n\n        local svgcode = \"\"\n        svgcode = svgcode .. string.format([[\n            <line x1=\"%d\" y1=\"%d\" x2=\"%d\" y2=\"%d\" stroke=\"darkgray\" stroke-width=\"6\" stroke-dasharray=\"12\" />\n            <text x=\"%d\" y=\"%d\" font-size=\"50\" fill=\"%s\">Direct trajectory, %s su in danger zone</text>\n            <g font-size=\"50\" fill=\"%s\">\n            <text x=\"%d\" y=\"%d\">Direct trajectory, %s su in</text></g>]],\n            screenPos.x, screenPos.y-17, screenPos.x + 90, screenPos.y-17,\n            screenPos.x + 110, screenPos.y, self.dangerZonesColors[1], round(dangerDist, 2),\n            self.color,\n            screenPos.x + 110, screenPos.y, round(dangerDist, 2))\n        return svgcode\n    end\n    function    sti:getSvgShipState(ypos, x1, x2)--and safe zone projection on the plan({origin, destination, shipPos})\n        local k = self.kinematics\n        local xfloor = floor(x1 + k.progressRatio * k.warpLineScreenLen)\n        local yship = floor(k.shipHeight / k.scale.y)\n        local ySu = min(yship, 350)\n\n        local svgcode = \"\"\n        --planet on warp line\n        svgcode = svgcode .. string.format([[\n            <circle cx=\"%d\" cy=\"%d\" r=\"%d\" fill=\"%s\" />\n            <circle cx=\"%d\" cy=\"%d\" r=\"%d\" fill=\"%s\" />]],\n            x1-25, ypos, 38, self.color,\n            x2+25, ypos, 38, self.color)\n\n        --ship height and pos\n        local offset, anchor = 30, \"start\"\n        if xfloor > g.w/2 then\n            offset = -offset\n            anchor = \"end\"\n        end\n        svgcode = svgcode .. string.format([[\n            <line x1=\"%d\" y1=\"%d\" x2=\"%d\" y2=\"%d\" stroke=\"darkgray\" stroke-width=\"3\" />\n            <line x1=\"%d\" y1=\"%d\" x2=\"%d\" y2=\"%d\" stroke=\"darkgray\" stroke-width=\"6\" stroke-dasharray=\"12\" />\n            <circle cx=\"%d\" cy=\"%d\" r=\"12\" fill=\"black\" stroke=\"white\" stroke-width=4 />\n            <text x=\"%d\" y=\"%d\" font-size=\"50\" fill=\"white\" stroke=\"black\" stroke-width=\"20\" text-anchor=\"%s\">%s</text>]],\n            xfloor, ypos, xfloor, ypos-yship,\n            x2, ypos, xfloor, ypos-yship,\n            xfloor, ypos-yship,\n            xfloor+offset, ypos-ySu+30, anchor, (round(k.shipHeight/su, 2)..\" su ↥\"))\n\n        --text : danger zone if going right to desto\n        svgcode = svgcode .. self:getSvgDangerZoneForDirectTrajectory(ypos, k.shipHeight, k.shipPos, k.destination)\n        \n        -- safe zone bubble\n        local svgSafeZone = \"\"\n\n        -- manual recon\n        -- for yy=1, 10, 1 do\n        --     for xx=5, 35, 1 do\n        --         local fakepos = k.coosys.origin + k.coosys.x*xx*su*2.5 + k.coosys.y*yy*su*1\n        --         local safefrontierDist = self.safeZone.r - (fakepos - self.safeZone.center):len()\n        --         local color = (safefrontierDist > 0) and \"green\" or \"red\"\n        --         svgSafeZone = svgSafeZone .. string.format([[\n        --             <circle cx=\"%d\" cy=\"%d\" r=\"5\" fill=\"%s\" />]],\n        --             floor(x1 + (xx*su*2.5 / k.scale.x)),\n        --             floor(ypos - (yy*su*1 / k.scale.y)),\n        --             color)\n        --     end\n        -- end\n\n        if k.safeZoneCircle.r > 0 then\n            local proj = {-- projected in the coosys and scaled to the screen\n                x = x1 + k.safeZoneCircle.center:dot(k.coosys.x) / k.scale.x,\n                y = ypos - k.safeZoneCircle.center:dot(k.coosys.y) / k.scale.y,\n            }\n            svgSafeZone = svgSafeZone .. string.format([[\n                <ellipse cx=\"%d\" cy=\"%d\" rx=\"%d\" ry=\"%d\" fill-opacity=\"0.15\" fill=\"#33cc33\" stroke=\"#33cc33\" stroke-width=\"3\" />]],\n                floor(proj.x), floor(proj.y), floor(k.safeZoneCircle.r / k.scale.x), floor(k.safeZoneCircle.r / k.scale.y))\n        end\n        return svgSafeZone .. svgcode\n    end\n    function    sti:getSvgBti(screenPos)\n        local svgcode = \"\"\n        -- svgcode = svgcode .. string.format([[\n        --     <rect x=\"%d\" y=\"%d\" width=\"%d\" height=\"%d\" stroke=\"none\" fill=\"%s\" stroke-width=\"3\" stroke-dasharray=\"4\"/>]],\n        --     0, 0, g.w, 500, \"url(#black-topdown)\")\n        svgcode = svgcode .. self.bti:getSvgcode(screenPos, self.bti.waypoints[self.destination])\n        return svgcode\n    end\n\n    function    sti:initHeightsGrid(screenPos) --need bti\n        self.grid = {\n            heights = sti.getHeightsFor(self.shipPos, self.bti.waypoints),\n            buttons = {},\n            buttonsGrid = {},\n        }\n        local count = #self.bti.waypoints\n        local pad = 0\n        local s = 32\n        self.grid.rect = Rect(screenPos.x, screenPos.y, (s+pad)*count, (s+pad)*count)\n\n        for j = 1, count do\n            self.grid.buttonsGrid[j] = {}\n            for i = j+1, count do\n                local b = Button(nil, screenPos + vec3((i-1)*(s+pad), (j-1)*(s+pad), 0), {width=s,height=s})\n                b.selected = false\n                b.canToggle = false\n                b.showHintWhenHovered = true\n                b.hint = self.bti.waypoints[j].name .. \"⇔\" .. self.bti.waypoints[i].name --⇔\n                b.color = \"green\"\n                self.grid.buttonsGrid[j][i] = b\n                table.insert(self.grid.buttons, b)\n            end\n        end\n    end\n    function    sti:getHeightColor(height)\n        for i, h in ipairs(self.dangerZonesHeights) do \n            if height < h then\n                return self.dangerZonesColors[i]\n            end\n        end\n        return \"none\"\n    end\n    function    sti.getHeightsFor(shipPos, waypoints)\n        local heights = {} -- array of array for 2d grid halved (x:y = y:x and x=y is impossible)\n        local bodyCount = #waypoints\n        for j = 1, bodyCount do\n            heights[j] = {}\n            heights[j][j] = -1 -- should never use this entry\n            local origin = vec3(waypoints[j])\n            for i = j+1, bodyCount do\n                local destination = vec3(waypoints[i])\n                heights[j][i] = sti.getHeight(shipPos, origin, destination)\n            end\n        end\n        return heights\n    end\n    function    sti:updateGridButtonsStates(cursorPos)\n        local changes = false\n        if isWithinRect(self.grid.rect, cursorPos) then\n            changes = Button.updateButtonsStates(self.grid.buttons, cursorPos)\n        else--manual reset of hover cauz out of the box\n            for i, b in ipairs(self.grid.buttons) do\n                if b.hovered then\n                    b.hovered = false\n                    changes = true\n                end\n            end\n        end\n        if changes then\n            g.needRefresh = true\n        end\n    end\n    function    sti:getSvgGrid()\n        local svgcode = \"\"\n        for i, b in ipairs(self.grid.buttons) do\n            -- if b.active then\n                svgcode = svgcode .. b:draw(nil, {noRound=true})\n            -- end\n        end\n        return svgcode\n    end\n    function    sti:updateGridHeights(shipPos)\n        shipPos = shipPos or vec3(core.getConstructWorldPos())\n        self.grid.heights = sti.getHeightsFor(shipPos, self.bti.waypoints)\n        local bodyCount = #self.bti.waypoints\n        for j = 1, bodyCount do\n            for i = j+1, bodyCount do\n                self.grid.buttonsGrid[j][i].color = self:getHeightColor(self.grid.heights[j][i])\n                 --⇔\n                self.grid.buttonsGrid[j][i].hint = string.format([[%s⇔%s %s su]],\n                    self.bti.waypoints[j].name, self.bti.waypoints[i].name, round(self.grid.heights[j][i]/su,2))\n                self.grid.buttonsGrid[j][i].active = (self.grid.heights[j][i] < self.dangerZonesHeights[3]) and true or false\n            end\n        end\n    end\n    function    sti:getHtmlCompleteGrid()\n        local bodyCount = #self.bti.waypoints\n        local htmlcode = \"\"\n        --header\n        local classes = {\"danger1\",\"danger2\",\"danger3\",\"no-danger\"}\n        htmlcode = htmlcode .. string.format([[\n            <style>\n            tr th {font-size:4.2vh;font-family:Arial;}\n            .%s {color:%s}\n            .%s {color:%s}\n            .%s {color:%s}\n            .%s {color:%s}\n            </style>\n            <div style=\"width:100%%;height:100%%;\">\n            <table style=\"width:100%%;height:100%%\">]],\n            classes[1], self.dangerZonesColors[1],\n            classes[2], self.dangerZonesColors[2],\n            classes[3], self.dangerZonesColors[3],\n            classes[4], \"white\")\n        htmlcode = htmlcode .. [[<tr>]]\n        for i = 2, bodyCount do\n                htmlcode = htmlcode .. string.format([[<th>%s</th>]], self.bti.waypoints[i].name)\n        end\n        htmlcode = htmlcode .. string.format([[<th></th></tr>]])\n        --rows\n        for j = 1, bodyCount-1 do\n            htmlcode = htmlcode .. [[<tr>]]\n            for i = 2, bodyCount do\n                local height = \"\"\n                local class = \"\"\n                if (i > j) then\n                    height = self.grid.heights[j][i]\n                    class = classes[4]\n                    for i, h in ipairs(self.dangerZonesHeights) do \n                        if height < h then\n                            class = classes[i]\n                            break\n                        end\n                    end\n                    class = string.format([[class=\"%s\"]], class)\n                    local close = 8*su\n                    if height > close then -- white gradient\n                        local c = max(50,floor(255*(1-(height-close)/(20*su))))\n                        class = string.format([[style=\"color:rgb(%d, %d, %d);\"]], c,c,c)\n                    end\n                    local d = height < (10*su) and 2 or 1\n                    height = round(height/su, d)\n                end\n                htmlcode = htmlcode .. string.format([[<th %s>%s</th>]], class, height)\n            end\n            htmlcode = htmlcode .. string.format([[<th>%s</th>]], self.bti.waypoints[j].name)\n            htmlcode = htmlcode .. [[</tr>]]\n        end\n        htmlcode = htmlcode .. [[</table></div>]]\n        return htmlcode\n    end\n\n    -- adapted JayleBreak function PlanetarySystem:closestBody(coordinates)\n    function    sti:getClosestBody(shipPos)\n        --planets\n        local minDistance2 = (self.atlas[1].center - shipPos):len2()\n        local body = self.atlas[1]\n        for _, b in ipairs(self.atlas) do\n            local distance2 = (b.center - shipPos):len2()\n            if distance2 < minDistance2 then\n                body = b\n                minDistance2 = distance2\n            end\n        end\n        --moons\n        for _, m in ipairs(body.moons) do\n            local distance2 = (m.center - shipPos):len2()\n            if distance2 < minDistance2 then\n                body = m\n                minDistance2 = distance2\n            end\n        end\n        return body, sqrt(minDistance2)\n    end\n    function    sti:getSvgSafeZoneStatus(shipPos, screenPos)\n        screenPos = screenPos or vec3(10, 10, 0)\n        local safefrontierDist = self.safeZone.r - (shipPos - self.safeZone.center):len()\n        --planetary protection\n        local closestBody, closestBodyDist = sti:getClosestBody(shipPos)\n        local bodyFrontierDist = 500000 - closestBodyDist -- 2.5su\n        local safe = (safefrontierDist > 0) or (bodyFrontierDist > 0)\n\n        local svgcode = \"\"\n        --icons\n        svgcode = svgcode .. string.format([[<use x=\"%d\" y=\"%d\" fill=\"%s\" xlink:href=\"#pvp\" />]],\n            screenPos.x, screenPos.y, safe and self.color or \"#ff4d4d\")\n        if safe then\n            svgcode = svgcode .. string.format([[<use x=\"%d\" y=\"%d\" fill=\"#33cc33\" xlink:href=\"#safe\" />]],\n                screenPos.x+85, screenPos.y+125)\n        end\n        --text\n        local textpos = screenPos + vec3(140, 310, 0)\n        local fs = 28\n        local pad = 3\n        svgcode = svgcode .. string.format([[\n            <g text-anchor=\"middle\" fill=\"%s\" font-size=\"%d\">\n            <text x=\"%d\" y=\"%d\">Boundarys:</text>\n            <text x=\"%d\" y=\"%d\">%s - Safe Zone</text>\n            <text x=\"%d\" y=\"%d\">%s - %s</text>\n            </g>]],\n            self.color, fs,\n            textpos.x, textpos.y,\n            textpos.x, textpos.y+fs*1+pad*2, fancy_sukm(abs(safefrontierDist)),\n            textpos.x, textpos.y+fs*2+pad*1, fancy_sukm(abs(bodyFrontierDist)), closestBody.name)\n            return svgcode\n    end\n\n    function    sti:getSvgcode(shipPos)\n        self.shipPos = shipPos or vec3(core.getConstructWorldPos())\n        local svgcode = \"\"\n        -- first panel\n        local ypos = floor(g.h*0.70)\n        local x1 = 250\n        local x2 = g.w - x1\n        self:calculateKinematics(x1, x2, self.shipPos, core.getWorldAbsoluteVelocity(), core.getConstructWorldForward())\n        svgcode = svgcode .. self:getSvgPlanetZones(ypos, x1, x2) -- planets BG images\n        svgcode = svgcode .. self:getSvgDangerZones(ypos, x1, x2) -- colored danger zones in BG\n        if self.displayMoreTrajectorys then\n            svgcode = svgcode .. self:getSvgTrajectorys(ypos, x1, x2) -- /!\\ higher CPU cost -- 2 more trajectorys : velocityVec, forwardVec\n        end\n        svgcode = svgcode .. self:getSvgShipState(ypos, x1, x2) -- ship status: height + danger zone text on bottom\n        svgcode = svgcode .. self:getSvgBti(vec3(30, 60, 0)) -- bti top left\n        self:updateGridHeights(self.shipPos)\n        svgcode = svgcode .. self:getSvgGrid() -- small grid, top\n        svgcode = svgcode .. self:getSvgSafeZoneStatus(self.shipPos, vec3(1580,15,0)) -- safe zone icon and boundarys, top right\n        return svgcode\n    end\n    function    sti:getLateSvgcode()\n        local svgcode = \"\"\n        for i, b in ipairs(self.grid.buttons) do\n            if b.active then\n                svgcode = svgcode .. b:lateDraw()\n            end\n        end\n        return svgcode\n    end\n\n    return sti\nend\n\nfunction    requirePlanetSelector()\n    local ps = {}\n    ps.color = \"darkgray\"\n    ps.y = floor(g.h*0.4)\n    ps.fontsize = 45\n    ps.indent = 10\n    \n    --planets\n    ps.buttons = {}\n    ps.planetSelectionOrigin = ButtonGroup()\n    ps.planetSelectionDestination = ButtonGroup()\n    ps._destinationIndexMap = {}\n    ps._originIndexMap = {}\n\n    --simulation\n    ps.simulation = {\n        textPos = vec3(floor(g.w*0.15), floor(g.h*0.98), 0),\n        fontsize = 40,\n        mode = 0, -- 0=direct 1=velocityVec 2=forwardVec\n        running = false,\n        repeating = true,\n        automaticSpeed = true,\n        deltaTime = 1/20, -- 1/Xfps\n        duration = 5, --sec\n        shipSpeed = 10*su, -- / sec, if automaticSpeed, adapted depending on travel dist\n        shipTrajectory = vec3(core.getConstructWorldOrientationForward()):normalize(),\n    }\n    ps.simulation.toggleButton = Button(\"Run simulation\", ps.simulation.textPos + vec3(0,-ps.simulation.fontsize,0), {width=310,height=44}, 35)\n    ps.simulation.toggleButton.canToggle = true\n    ps.simulation.toggleButton.onClick = toggleSimulation\n    table.insert(ps.buttons, ps.simulation.toggleButton)\n\n    ps.simulation.switchModeButton = Button(\"direct\", ps.simulation.textPos + vec3(430,-ps.simulation.fontsize,0), {width=185,height=44}, 35)\n    ps.simulation.switchModeButton.canToggle = false\n    ps.simulation.switchModeButton.onClick = switchSimulationMode\n    table.insert(ps.buttons, ps.simulation.switchModeButton)\n\n    --▲ ▼ ◀ ▶ ◢ ◣ ◥ ◤\n    ps.simulation.trajectorysButton = Button(\"[\", vec3(247, floor(g.h*0.71) + 175, 0), {width=37,height=75}, 55)\n    ps.simulation.trajectorysButton.canToggle = true\n    ps.simulation.trajectorysButton.showHintWhenHovered = true\n    ps.simulation.trajectorysButton.hint = \"toggle trajectorys prediction (higher CPU cost)\"\n    ps.simulation.trajectorysButton.flags = {noRound=true}\n    ps.simulation.trajectorysButton:_click()\n    ps.simulation.trajectorysButton.onClick = toggleTrajectoryDisplay\n    table.insert(ps.buttons, ps.simulation.trajectorysButton)\n\n    function    ps:initPlanets(planets)\n        local size = {width=175,height=50}\n        local ftsize = 35\n        for i, v in ipairs(sti.bti.waypoints) do\n            local b1 = Button(v.name, vec3(self.indent,self.y+(size.height+4)*(i-1),0), size, ftsize)\n            b1.buttonGroup = self.planetSelectionOrigin\n            b1.active = true\n            b1.canToggle = true\n            b1.onClick = selectOrigin\n            self.planetSelectionOrigin:add(b1)\n            table.insert(self.buttons, b1)\n            self._originIndexMap[v.name] = i\n\n            local b2 = Button(v.name, vec3(g.w-self.indent-size.width,self.y+(size.height+4)*(i-1),0), size, ftsize)\n            b2.buttonGroup = self.planetSelectionDestination\n            b2.active = true\n            b2.canToggle = true\n            b2.onClick = selectDestination\n            self.planetSelectionDestination:add(b2)\n            table.insert(self.buttons, b2)\n            self._destinationIndexMap[v.name] = i\n        end\n    end\n    function    ps:update(cursorPos)\n        local changes = Button.updateButtonsStates(self.buttons, cursorPos)\n        if changes then\n            g.needRefresh = true\n        end\n    end\n    function    ps:getSvgcode()\n        local svgcode = \"\"\n        --simulation text\n        svgcode = svgcode .. string.format([[\n            <text x=\"%d\" y=\"%d\" font-size=\"%d\" fill=\"%s\" stroke=\"black\" stroke-width=\"10\">%s</text>\n            <text x=\"%d\" y=\"%d\" font-size=\"%d\" fill=\"%s\" stroke=\"black\" stroke-width=\"10\">%s</text>]],\n            self.simulation.textPos.x + 320, self.simulation.textPos.y, self.simulation.fontsize, self.color, \"with\",\n            self.simulation.textPos.x + 620, self.simulation.textPos.y, self.simulation.fontsize, self.color, \"trajectory.\")\n        --planet selector\n        svgcode = svgcode .. string.format([[\n            <rect x=\"%d\" y=\"%d\" width=\"%d\" height=\"%d\" stroke=\"none\" fill=\"%s\" stroke-width=\"3\" stroke-dasharray=\"4\"/>]],\n            0, self.y, 190, g.h-self.y, \"url(#black-leftright)\")\n        svgcode = svgcode .. string.format([[\n            <rect x=\"%d\" y=\"%d\" width=\"%d\" height=\"%d\" stroke=\"none\" fill=\"%s\" stroke-width=\"3\" stroke-dasharray=\"4\"/>]],\n            g.w-190, self.y, 190, g.h-self.y, \"url(#black-rightleft)\")\n        svgcode = svgcode .. string.format([[\n            <text x=\"%d\" y=\"%d\" font-size=\"%d\" fill=\"%s\" stroke=\"black\" stroke-width=\"10\">%s</text>\n            <text x=\"%d\" y=\"%d\" font-size=\"%d\" fill=\"%s\" stroke=\"black\" stroke-width=\"10\" text-anchor=\"end\">%s</text>]],\n            self.indent, self.y-self.indent, self.fontsize, self.color, \"Origin:\",\n            g.w-self.indent, self.y-self.indent, self.fontsize, self.color, \"Destination:\")\n        for i, v in ipairs(self.buttons) do\n            svgcode = svgcode .. v:draw()\n        end\n\n        return svgcode\n    end\n    function    ps:getLateSvgcode()\n        local svgcode = \"\"\n        for i, v in ipairs(self.buttons) do\n            svgcode = svgcode .. v:lateDraw()\n        end\n        return svgcode\n    end\n    function    ps:tryClick(x, y)\n        Button.tryClickOnButtons(self.buttons, {x=x, y=y})\n    end\n\n    function    ps:prepareSimulation()\n        self.simulation.startedAt = system.getTime()\n        if self.simulation.mode == 0 then\n            self.simulation.shipTrajectory = sti.kinematics.directTrajectoryVec:normalize()\n        elseif self.simulation.mode == 1 then\n            self.simulation.shipTrajectory = sti.kinematics.velocityTrajectoryVec:normalize()\n        elseif self.simulation.mode == 2 then\n            self.simulation.shipTrajectory = sti.kinematics.forwardTrajectoryVec:normalize()\n        else\n            --impossible case\n        end\n        if self.simulation.automaticSpeed then\n          --  local travelDist = (sti.bti.waypoints[sti.destination] - sti.shipPos):len()\n            self.simulation.shipSpeed = sti.kinematics.travelDist / self.simulation.duration * overshootRatio\n        end\n    end\n    function    ps:toggleSimulation(forcedState)\n        self.simulation.running = (forcedState ~= nil) and forcedState or (not self.simulation.running)\n        if self.simulation.running then\n            self:prepareSimulation()\n            unit.setTimer(\"simulation\", self.simulation.deltaTime)\n        else\n            unit.stopTimer(\"simulation\")\n            g.needRefresh = true\n        end\n    end\n    function    ps:runSimulationStep()\n        sti.shipPos = sti.shipPos + self.simulation.shipTrajectory * self.simulation.shipSpeed * self.simulation.deltaTime\n        --stop or repeat simu if duration expires\n        if system.getTime() - self.simulation.startedAt > self.simulation.duration then\n            if self.simulation.repeating then\n                sti.shipPos = vec3(core.getConstructWorldPos())\n                self.simulation.startedAt = system.getTime()\n            else\n                self.simulation.toggleButton:_click()\n            end\n        end\n    end\n\n    return ps\nend\n\n--button funcs\nfunction    selectOrigin()\n    local b = selector.planetSelectionOrigin.selected[1]\n    if b then \n        local old_origin = sti.origin\n        sti.origin = selector._originIndexMap[b.text]\n        if sti.destination == sti.origin then\n            selector.planetSelectionDestination[old_origin]:_click()\n        end\n        g.needRefresh = true\n    else -- clicked on the current selection, just reselect it (= always 1 selected)\n        selector.planetSelectionOrigin[sti.origin]:_click()\n    end\nend\nfunction    selectDestination()\n    local b = selector.planetSelectionDestination.selected[1]\n    if b then \n        local old_destination = sti.destination\n        sti.destination = selector._destinationIndexMap[b.text]\n        if sti.origin == sti.destination then\n            selector.planetSelectionOrigin[old_destination]:_click()\n        end\n        g.needRefresh = true\n    else -- unselected the current selection, just reselect it (always 1 selected)\n        selector.planetSelectionDestination[sti.destination]:_click()\n    end\nend\nfunction    toggleSimulation()\n    selector:toggleSimulation()\n    selector.simulation.switchModeButton.active = not selector.simulation.switchModeButton.active\nend\nfunction    switchSimulationMode()\n    local modes = {\"direct\", \"velocity\", \"forward\"}\n    selector.simulation.mode = (selector.simulation.mode + 1) % 3\n    selector.simulation.switchModeButton.text = modes[selector.simulation.mode+1]\n    g.needRefresh = true\nend\nfunction    toggleTrajectoryDisplay()\n    sti.displayMoreTrajectorys = not sti.displayMoreTrajectorys\n    g.needRefresh = true\nend","filter":{"args":[],"signature":"start()","slotKey":"-3"},"key":"8"},{"code":"--v1.3\nfunction requireSvgHelper()\n    local function isTable(t)   return type(t) == 'table'  end\n\n    local svg = {}\n    svg._fontsize = 20\n    svg._pad = 4\n    svg._tablepad = 30\n    svg._textColor = \"yellow\"\n    svg._displayKey = true\n    svg._displayTable = true\n\n    function svg.dump()\n        return svg.header .. \"<style>\" .. svg.style .. \"</style><defs>\" .. svg.base .. \"</defs>\" .. svg.body .. svg.footer\n    end\n\n    function svg.toSVG(arr, x, ystart, settings, depth)\n        local svgtext = \"\"\n        ystart = ystart or 20\n        x = x or 25\n        settings = settings or {}\n        settings.maxDepth = settings.maxDepth or 99999\n        if (settings.displayKey == nil) then settings.displayKey = svg._displayKey end\n        if (settings.displayTable == nil) then settings.displayTable = svg._displayTable end\n        depth = depth or 0\n\n        local i = 0\n        local ii = 0\n        for k, v in pairs(arr) do\n            i = i + 1\n            if (depth == 0) then ii = ii + 1 end\n            local valueIsTable = isTable(v)\n            svgtext = svgtext .. string.format([[\n                <text x=\"%d\" y=\"%d\"\n                font-size=\"%dpx\" fill=\"%s\" stroke=\"black\" stroke-width=\"2\">\n                %s%s\n                </text>\n                ]], x + depth*svg._tablepad, (ystart + (i + ii - 1)*(svg._fontsize + svg._pad)),\n                svg._fontsize, svg._textColor,\n                settings.displayKey and (k..\" : \") or \"\", valueIsTable and \"{...}\" or v)\n            if (settings.displayTable and valueIsTable and (depth <= settings.maxDepth)) then\n                local svgtable, ret = svg.toSVG(v, x, (ystart + (i + ii)*(svg._fontsize + svg._pad)), settings, depth+1)\n                ii = ii + ret\n                svgtext = svgtext .. svgtable\n            end\n        end\n        return svgtext, i + ii\n    end\n\n    function svg.imageCut(path, imageSize, screenViewbox, svgViewbox) -- viewbox are rect: x y width height\n        return string.format([[\n            <svg x=\"%d\" y=\"%d\" width=\"%d\" height=\"%d\" preserveAspectRatio=\"none\"\n            viewBox=\"%d %d %d %d\"\n            xmlns=\"http://www.w3.org/2000/svg\" \n            xmlns:xlink=\"http://www.w3.org/1999/xlink\"> \n            <image width=\"%d\" height=\"%d\" xlink:href=\"%s\" />\n            </svg>]],\n            screenViewbox.x, screenViewbox.y, screenViewbox.width, screenViewbox.height,\n            svgViewbox.x, svgViewbox.y, svgViewbox.width, svgViewbox.height,\n            imageSize.width, imageSize.height, path)\n    end\n\n    function\tsvg.textBG(text, position, fontsize, color, inverted)--inverted is like an unselected button\n        local pos = position and {x=position.x, y=position.y} or {x=0, y=0}\n        fontsize = fontsize and math.floor(fontsize) or 15\n        color = color or \"white\"\n        inverted = inverted or false\n        local textcolor = inverted and color or \"black\"\n        local stroke = inverted and (\"stroke-width:1;stroke:\" .. color) or \"\"\n        color = inverted and \"none\" or color\n        local x = math.floor(pos.x)\n        local y = math.floor(pos.y)\n        local pad = 0.35\n        local textlen = math.floor(fontsize * string.len(text) * 0.6) --depend of the font\n        local xlen = math.floor(fontsize*pad*2) + textlen\n        local ylen = math.floor(fontsize*(1+pad))\n        local round = math.floor(fontsize*0.4)\n        \n        local svgcode = string.format([[\n            <rect x=\"%d\" y=\"%d\" width=\"%d\" height=\"%d\" rx=\"%d\" ry=\"%d\" style=\"fill:%s;%s\" />\n            <text x=\"%d\" y=\"%d\" textLength=\"%d\" font-size=\"%d\" font-weight=\"bold\" fill=\"%s\">%s</text>]],\n            x, y, xlen, ylen, round, round, color, stroke,\n            x + math.floor(fontsize*pad), y + fontsize, textlen, fontsize, textcolor, text)\n        \n        return svgcode\n    end\n    \n    function\tsvg.tag(title, description, pos, fontsize, color)\n        color = color or \"white\"\n        fontsize = fontsize and math.floor(fontsize) or 20\n        local keyftsize = math.floor((13/20)*fontsize)\n        local x = math.floor(pos.x)\n        local y = math.floor(pos.y)\n        local svgcode = svgTextBG(title, {x=x, y=y}, keyftsize, color)\n        x = math.floor(x + (string.len(title)+2) * keyftsize * 0.6)\n        svgcode = svgcode .. string.format([[\n            <text x=\"%d\" y=\"%d\" font-size=\"%dpx\" fill=\"%s\">%s</text>]],\n            x, y+math.floor((15/20)*fontsize), fontsize, color, description)\n        \n        return svgcode\n    end\n    \n\n    svg.header = [[\n    <svg class=\"svg\" viewBox=\"0 0 1920 1080\" preserveAspectRatio=\"none\" \n    xmlns=\"http://www.w3.org/2000/svg\" \n    xmlns:xlink=\"http://www.w3.org/1999/xlink\"> \n    ]]\n    svg.style = [[\n    .svg {position:absolute;left:0;top:0;height:100vh;width:100vw;}\n    ]]\n    svg.base = [[]]\n    svg.footer = [[</svg>]]\n    svg.body = [[]]\n\n    return svg\nend","filter":{"args":[],"signature":"start()","slotKey":"-3"},"key":"9"},{"code":"-- Button ButtonGroup VirtualCursor\n-- v1.5 (NQ event:: API)\n--[[\n\t+ si trop de boutons à check avec le vcursor, les register dans un tree (quad?)\n\tou simplement diviser l'ecrans en quelques zones (attention aux overlaps)\n    + pas de depth pour l'instant\n    \n    todo: ButtonGroup: need to know the index of the button clicked\n]]\n\nfunction doNothing() end\n\nfunction requireButton()\n    -- Button\n    local Button = {}\n    Button.__index = Button\n    Button._color = \"white\"\n    Button.hintFontsizeMin = 15\n\n    --636363 99ccff\n    function\tButton:updateSvghelper(svgh)\n        svgh.style = svgh.style .. string.format([[\n            .button-rect-default { stroke-width:1; stroke:%s; fill:none; }\n            .button-rect-hovered { stroke-width:1; stroke:%s; fill:%s; }\n            .button-rect-selected { stroke-width:1; stroke:%s; fill:%s; }\n            .button-text-default { fill:%s; font-weight:bold; }\n            .button-text-hovered { fill:%s; font-weight:bold; }\n            .button-text-selected { fill:%s; font-weight:bold; }]],\n            self._color,\n            \"#5588ff\", \"#5588ff\",\n            self._color, self._color,\n            self._color,\n            \"black\",\n            \"black\")\n    end\n\n    function\tButton.updateButtonsStates(buttons, cursorPos)\n        if buttons == nil then\n            return false\n        end\n        local changes = false\n        for _, b in pairs(buttons) do\n            local c = b:updateState(cursorPos)\n            if not changes then\n                changes = c\n            end\n        end\n        return changes\n    end\n    function\tButton:updateState(cursorPos)\n        if self.active then\n            -- system.print(\"Button.updateButtonsStates : \" .. b.text)\n            local oldhover = self.hovered\n            self.hovered = self.rect:contains(cursorPos)\n            if self.hovered then self.onHover(self) end\n            if oldhover ~= self.hovered then\n                return true\n            end\n        end\n        return false\n    end\n\n    function    Button.tryClickOnButtons(buttons, cursorPos)\n        if buttons == nil then\n            return false\n        end\n        local clicked = false\n        for _, b in pairs(buttons) do\n            local c = b:tryClick(cursorPos)\n            if not clicked then\n                clicked = c\n            end\n        end\n        return clicked\n    end\n    function    Button:tryClick(cursorPos)\n        --could only check if hovered, but it's not correct (a button could have the state hovered without being actually hovered)\n        if self.active then\n            if self.rect:contains(cursorPos) then\n                self:_click()\n                return true\n            end\n        end\n        return false\n    end\n\n\n    function Button.new(text, pos, size, fontsize)\n        local b = {\n            rect = Rect{\n                x = pos.x,\n                y = pos.y,\n                width=size.width,\n                height=size.height,\n            },\n            fontsize = fontsize or 15,\n            active = true,\n            hovered = false, -- need bitmask\n            selected = false, -- need bitmask\n            canToggle = false,\n            showHintWhenHovered = false,\n            buttonGroup = nil, -- a reference for buttons where only one can be selected at a time (later: several while holding shift)\n            text = text,\n            hint = nil,\n            onHover = doNothing, -- a user defined func\n            onClick = doNothing, -- a user defined func\n        }\n        b = setmetatable(b, Button)\n        return b\n    end\n    \n    function Button:_click()\n        --system.print(\"_click \" .. self.text)\n        if self.canToggle then\n            self:toggle()\n        end\n        self.onClick(self)\n    end\n\n    function Button:toggle()\n        self.selected = not self.selected\n        if self.buttonGroup then\n            self.buttonGroup:clearSelected() -- if shift is not down\n            if self.selected then \n                self.buttonGroup:addSelected(self)\n            end\n        end\n    end\n    \n    function Button:draw(newpos, flags)\n        flags = flags or self.flags or {}\n        if newpos then\n            self.rect.x = newpos.x\n            self.rect.y = newpos.y\n        end\n        --reduce class name len?\n        local rectclass = \"button-rect-default\"\n        if self.selected then rectclass = \"button-rect-selected\"\n        elseif self.hovered then rectclass = \"button-rect-hovered\" end\n        local textclass = \"button-text-default\"\n        if self.selected then textclass = \"button-text-selected\"\n        elseif self.hovered then textclass = \"button-text-hovered\" end\n        local textposY = math.floor(self.rect.y + self.fontsize + 0.2*(self.rect.height-self.fontsize))\n        local round = math.floor(self.fontsize*0.4)\n        local roundpp = flags.noRound and \"\" or string.format([[rx=\"%d\" ry=\"%d\"]], round, round)\n        local fillpp = self.color and string.format([[style=\"fill:%s;\"]], self.color) or \"\"\n        local svgcode = \"\"\n\n        if self.hovered or self.selected or flags.drawBorder ~= false then\n            svgcode = svgcode .. string.format([[\n                <rect x=\"%d\" y=\"%d\" width=\"%d\" height=\"%d\" %s class=\"%s\" %s />]],\n                self.rect.x, self.rect.y, self.rect.width, self.rect.height, roundpp, rectclass, fillpp)\n        end\n        if self.text and self.text ~= \"\" then\n            svgcode = svgcode .. string.format([[\n                [[<text x=\"%d\" y=\"%d\" font-size=\"%d\" class=\"%s\">%s</text>]],\n                self.rect.x+5, textposY, self.fontsize, textclass, self.text)\n        end\n        return svgcode\n    end\n\n    function    Button:lateDraw(newpos, flags)\n        local svgcode = \"\"\n        --hint if hovered\n        if self.showHintWhenHovered and self.hovered and self.hint then\n            local pos = vec3(self.rect.x + self.rect.width/2, self.rect.y - self.rect.height/2, 0)\n            svgcode = svgcode .. svg.textBG(\n                self.hint,\n                pos,    \n                math.max(math.ceil(self.fontsize*0.65), Button.hintFontsizeMin),\n                self._color)\n    end\n        return svgcode\n    end\n\n    -- ButtonGroup\n    local ButtonGroup = {}\n    ButtonGroup.__index = ButtonGroup\n    function ButtonGroup.new()\n        local bg = {\n            selected = {},\n        }\n        bg = setmetatable(bg, ButtonGroup)\n        return bg\n    end\n\n    function ButtonGroup:add(b) table.insert(self, b) end\n    function ButtonGroup:remove(b) table.remove(self, b) end\n\n    function ButtonGroup:clearSelected()\n        for i, button in ipairs(self.selected) do\n            button.selected = false\n            self.selected[i] = nil\n        end\n    end\n\n    function ButtonGroup:addSelected(b)\n        table.insert(self.selected, b)\n        --b.selected = true -- force selected button\n    end\n\n    function ButtonGroup:iter(imin, imax, f)\n        for i, b in ipairs(self) do\n            if i >= imin and i <= imax then\n                f(b)\n            end\n        end\n    end\n\n    --Vcursor\n    local VirtualCursor = {}\n    VirtualCursor.__index = VirtualCursor\n    VirtualCursor.pos = {x=1920/2, y=1080/2}\n    VirtualCursor.old = {x=1920/2, y=1080/2}\n\n    --deprecated, use Button.updateButtonsStates(buttons, cursorPos)\n    function\tVirtualCursor:updateButtonsStates(buttons)\n        if buttons == nil then\n            return false\n        end\n        local changes = false\n        for _, b in pairs(buttons) do\n            if b.active then\n                -- system.print(\"updateButtonsStates : \" .. b.text)\n                local oldhover = b.hovered\n                b.hovered = b.rect:contains(self.pos)\n                if b.hovered then b.onHover(b) end\n                if oldhover ~= b.hovered then changes = true end\n            end\n        end\n        return changes\n    end\n    --deprecated, use Button.tryClickOnButtons(buttons, cursorPos)\n    function\tVirtualCursor:tryClickOn(buttons)\n        if buttons == nil then\n            system.print(\"tryClickOn nil buttons\")\n            return false\n        end\n        local clicked = false\n        for _, b in pairs(buttons) do\n            if b.active then\n                if b.hovered then\n                    b:_click()\n                    clicked = true\n                end\n            end\n        end\n        return clicked\n    end\n\n    return setmetatable(Button, {\n            __call = function(_, ...) return Button.new(...) end\n        }),\n        setmetatable(ButtonGroup, {\n            __call = function(_, ...) return ButtonGroup.new(...) end\n        }),\n        VirtualCursor\nend\n","filter":{"args":[],"signature":"start()","slotKey":"-3"},"key":"10"},{"code":"--[[\n    BTI v1.4\n    dependency: SvgHelper\n    \n    unit > start\n        svg = requireSvgHelper() -- or require(\"svghelper\")\n        bti = requireBasicTravelInfos()\n        system.showScreen(1)\n        unit.setTimer(\"eta\", 0.25)\n    unit > tick(eta)\n        svg.body = bti:getSvgcode()\n        system.setScreen(svg.dump())\n    system > actionStart(lshift)\n        bti.target = (bti.target - 1 + bti.maxWaypoints - 1) % bti.maxWaypoints + 1\n    system > actionStart(lalt)\n        bti.target = (bti.target - 1 + bti.maxWaypoints + 1) % bti.maxWaypoints + 1\n\n]]\n\nlocal function dhms(time, displayAll, sep)\n    displayAll = displayAll or false\n    sep = sep or {\"d\",\"h\",\"m\",\"s\"}\n    local dhmsValues = {86400, 3600, 60, 1}\n    local res = \"\"\n    for i, v in ipairs(dhmsValues) do\n        local r = math.floor(time / dhmsValues[i])\n        time = time % dhmsValues[i]\n        if displayAll or r ~= 0 then\n            res = res .. string.format([[%.2d%s]], r, sep[i])\n        end\n    end\n    return res ~= \"\" and res or (\"0\"..sep[4])\nend\n\nlocal function buildWaypoints()\n    local helios = require(\"atlas\")[0]\n    local ibodys = {2,1,3,4,5,6,7,8,9,100,110,120}\n    local waypoints = {}\n    for i, b in ipairs(ibodys) do\n        waypoints[i] = {\n            name = helios[b].name[1],\n            x = helios[b].center[1],\n            y = helios[b].center[2],\n            z = helios[b].center[3],\n        }\n    end\n    return waypoints\nend\n\nfunction requireBasicTravelInfos()\n    local bti = {}\n    bti.waypoints = buildWaypoints()\n    bti.maxWaypoints = 0\n    for _, v in ipairs(bti.waypoints) do\n        bti.maxWaypoints = bti.maxWaypoints + 1\n    end\n    bti.target = 1\n    bti.color = \"#99ccff\"\n    bti.fontsize = 18\n\n    function\tbti:travelInfos(target, shipPos, speed, mass, pos, fontsize)\n        fontsize = fontsize or self.fontsize\n        pos = pos and pos or vec3(10, 30, 0)\n        local name = target.name or \"?\"\n        local dist = (shipPos - target):len()\n        local su = 200000\n        local t = 1000\n\n        local travel = {\n            atCurrentSpeed = math.floor(dist / speed),\n            atMaxSpeed = math.floor(dist / 8333),\n            warpCells = ((mass/t) * (dist/su) * 0.00024)\n        }\n\n        fontsize = fontsize or 20\n        local x = pos.x\n        local y = pos.y\n        local svgcode = string.format([[<g fill=\"%s\" font-size=\"%dpx\">]], self.color, fontsize)\n        --title\n        svgcode = svgcode .. string.format([[\n            <text x=\"%d\" y=\"%d\" font-weight=\"bold\" text-decoration=\"underline\">Travel time to %s (%dsu) :</text>]],\n            x, y, name, math.ceil(dist/su))\n        --current speed\n        y = y + fontsize\n        svgcode = svgcode .. string.format([[\n            <text x=\"%d\" y=\"%d\">At current speed: %s</text>]],\n            x, y, travel.atCurrentSpeed == 1/0 and \"∞\" or dhms(travel.atCurrentSpeed))\n        --max speed\n        y = y + fontsize\n        svgcode = svgcode .. string.format([[\n            <text x=\"%d\" y=\"%d\">At max speed: %s</text>]],\n            x, y, dhms(travel.atMaxSpeed))\n        --warp cell\n        y = y + fontsize\n        svgcode = svgcode .. string.format([[\n            <text x=\"%d\" y=\"%d\">Warp cells for %dt : %s</text>]],\n            x, y, math.ceil(mass/t), math.ceil(travel.warpCells))\n\n        svgcode = svgcode .. [[</g>]]\n        return svgcode\n    end\n    \n    function\tbti:getSvgcode(pos, target) -- target is a vec3 with a \"name\" key\n        local speed = vec3(core.getWorldVelocity()):len()\n        local selectedTarget = target and target or self.waypoints[self.target]\n        local shipPos = vec3(core.getConstructWorldPos())\n        local mass = core.getConstructMass()\n\n        return self:travelInfos(selectedTarget, shipPos, speed, mass, pos, self.fontsize)\n    end\n    \n    return bti\nend","filter":{"args":[],"signature":"start()","slotKey":"-3"},"key":"11"},{"code":"\nfunction isBetween(min, max, value)\n    return min <= value and max >= value\nend\nfunction isWithinRect(rect, pos)\n    return isBetween(rect.x, rect.x+rect.width, pos.x) and isBetween(rect.y, rect.y+rect.height, pos.y)\nend\n\nfunction requireRect()\n    local Rect = {}\n    Rect.__index = Rect\n\n    function Rect.new(x, y, width, height)\n        -- allow construction via (a, b, c, d), {a, b, c, d} or ({x=a, y=b, width=c, height=d})\n        if type(x) == \"table\" then\n            return setmetatable({\n                    x = x.x or x[1] or 0,\n                    y = x.y or x[2] or 0,\n                    width = x.width or x[3] or 0,\n                    height = x.height or x[4] or 0,\n                }, Rect)\n        else\n            return setmetatable({\n                    x = x or 0,\n                    y = y or 0,\n                    width = width or 0,\n                    height = height or 0,\n                }, Rect)\n        end\n    end\n\n    function Rect:contains(pos)\n        return isBetween(self.x, self.x+self.width, pos.x) and isBetween(self.y, self.y+self.height, pos.y)\n    end\n\n    return setmetatable( Rect, {\n            __call = function(_, ...) return Rect.new(...) end\n        })\nend\n","filter":{"args":[],"signature":"start()","slotKey":"-3"},"key":"12"},{"code":"local function getInfos(body)\n    return {\n        center = vec3(body.center),\n        name = body.name[1]\n    }\nend\nfunction requireAtlasCompact()\n    local helios = require(\"atlas\")[0]\n    local ibodys = {\n        --{planet, mooon 1, moon 2, ...}\n        {1,10,11,12},\n        {2,21,22,26},\n        {3,30,31},\n        {4,42,40,41},\n        {5,50},\n        {6,},\n        {7,70},\n        {8,},\n        {9,},\n        {100,102,103,101},\n        {110,},\n        {120,121,122},\n    }\n    local compact = {}\n    for i, group in ipairs(ibodys) do\n        for j, ibody in ipairs(group) do\n            if j == 1 then\n                compact[i] = getInfos(helios[ibody])\n                compact[i].moons = {}\n            else\n                compact[i].moons[j-1] = getInfos(helios[ibody])\n            end\n        end\n    end\n    return compact\nend","filter":{"args":[],"signature":"start()","slotKey":"-3"},"key":"13"}],"methods":[],"events":[]}
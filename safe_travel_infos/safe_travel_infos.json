{"slots":{"0":{"name":"core","type":{"events":[],"methods":[]}},"1":{"name":"screen","type":{"events":[],"methods":[]}},"2":{"name":"slot3","type":{"events":[],"methods":[]}},"3":{"name":"slot4","type":{"events":[],"methods":[]}},"4":{"name":"slot5","type":{"events":[],"methods":[]}},"5":{"name":"slot6","type":{"events":[],"methods":[]}},"6":{"name":"slot7","type":{"events":[],"methods":[]}},"7":{"name":"slot8","type":{"events":[],"methods":[]}},"8":{"name":"slot9","type":{"events":[],"methods":[]}},"9":{"name":"slot10","type":{"events":[],"methods":[]}},"-1":{"name":"unit","type":{"events":[],"methods":[]}},"-2":{"name":"system","type":{"events":[],"methods":[]}},"-3":{"name":"library","type":{"events":[],"methods":[]}}},"handlers":[{"code":"--print(\"mouse down : \" .. math.floor(x*g.w) .. \" \" .. math.floor(y*g.h))\nselector:tryClick(math.floor(x*g.w), math.floor(y*g.h))","filter":{"args":[{"variable":"*"},{"variable":"*"}],"signature":"mouseDown(x,y)","slotKey":"1"},"key":"0"},{"code":"--[[\n    Safe Travel Infos v1.3\n\n    links order:\n        1. core\n        2. screen\n\n    warning: this does not handle the safe zone\n]]\nsystem.showScreen(1)\nsystem.setScreen([[<svg class=\"svg\" x=\"0\" y=\"%d\" width=\"1920\" height=\"1920\" viewBox=\"0 0 1920 1080\" preserveAspectRatio=\"none\"\nxmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\">\n<style>\n.svg {position:absolute;left:0;top:0;height:100vh;width:100vw;</style>\n<text x=\"1915\" y=\"1075\" font-size=\"15\" fill=\"#99ccff\" stroke-width=\"3\" text-anchor=\"end\">STI v1.3</text>\n</svg>]])\n\nunit.hide()\nprint = system.print\nlocal main_color = \"#99ccff\"\nlocal screen_refresh = 15 --export: the screen blinks at each refresh, low values are not recommanded\nlocal d = 34\nlocal w = 1920\nlocal h = 1080 + d*2\ndebug = {}\ng = {\n    w = w,\n    h = h,\n    needRefresh = true,\n}\n\n---------------------\n--dep\nrect = requireRect()\nsvg = requireSvgHelper()\nsvg.header = string.format([[\n    <svg x=\"0\" y=\"%d\" width=\"%d\" height=\"%d\" viewBox=\"0 0 %d %d\" preserveAspectRatio=\"none\"\n        xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\"><style>]],\n    -d, w, h,  w, h)\nsvg._fontsize = 40\nButton, ButtonGroup, VirtualCursor = requireButton()\nButton.color = main_color\nButton:updateSvghelper(svg)\n\n---------------------\n--sti\nsti = requireSafeTravelInfos()\nsti:initBti(requireBasicTravelInfos())\nsti:setTextColor(main_color)\nsti.bti.fontsize = 50\nsti:updateSvghelper(svg)\n\n---------------------\n--planet selector\nselector = requirePlanetSelector()\nselector:initPlanets(sti.bti.waypoints)\nselector.color = main_color\n\n---------------------\n--start\n\nselector.planetSelectionOrigin[1]:_click()\nselector.planetSelectionDestination[2]:_click()\n--[[\n    1 Alioth\n    2 Madis\n    3 Thades\n    4 Talemai\n    5 Feli\n    6 Sicari\n    7 Sinnen\n    8 Teoma\n    9 Jago\n    10 Symeon\n    11 Ion\n    12 Lacobus\n]]\n\n\nscreen.activate()\nunit.setTimer(\"tv\", 0.05)\nunit.setTimer(\"refresh\", screen_refresh)","filter":{"args":[],"signature":"start()","slotKey":"-1"},"key":"1"},{"code":"screen.deactivate()","filter":{"args":[],"signature":"stop()","slotKey":"-1"},"key":"2"},{"code":"if g.needRefresh then\n    svg.body = \"\"\n    svg.body = svg.body .. sti:getSvgcode() .. selector:getSvgcode()\n    screen.setSVG(svg.dump())\n    g.needRefresh = false\nelse\nend","filter":{"args":[{"value":"tv"}],"signature":"tick(timerId)","slotKey":"-1"},"key":"3"},{"code":"g.needRefresh = true","filter":{"args":[{"value":"refresh"}],"signature":"tick(timerId)","slotKey":"-1"},"key":"4"},{"code":"selector:update()\n","filter":{"args":[],"signature":"update()","slotKey":"-2"},"key":"5"},{"code":"--v1.2\nfunction requireSvgHelper()\n    local function isTable(t)   return type(t) == 'table'  end\n\n    local svg = {}\n    svg._fontsize = 20\n    svg._pad = 4\n    svg._tablepad = 30\n    svg._textColor = \"yellow\"\n    svg._displayKey = true\n    svg._displayTable = true\n\n    function svg.dump()\n        return svg.header .. svg.style .. \"</style><defs>\" .. svg.base .. \"</defs>\" .. svg.body .. svg.footer\n    end\n\n    function svg.toSVG(arr, x, ystart, settings, depth)\n        local svgtext = \"\"\n        ystart = ystart or 20\n        x = x or 25\n        settings = settings or {}\n        settings.maxDepth = settings.maxDepth or 99999\n        if (settings.displayKey == nil) then settings.displayKey = svg._displayKey end\n        if (settings.displayTable == nil) then settings.displayTable = svg._displayTable end\n        depth = depth or 0\n\n        local i = 0\n        local ii = 0\n        for k, v in pairs(arr) do\n            i = i + 1\n            if (depth == 0) then ii = ii + 1 end\n            local valueIsTable = isTable(v)\n            svgtext = svgtext .. string.format([[\n                <text x=\"%d\" y=\"%d\"\n                font-size=\"%dpx\" fill=\"%s\" stroke=\"black\" stroke-width=\"2\">\n                %s%s\n                </text>\n                ]], x + depth*svg._tablepad, (ystart + (i + ii - 1)*(svg._fontsize + svg._pad)),\n                svg._fontsize, svg._textColor,\n                settings.displayKey and (k..\" : \") or \"\", valueIsTable and \"{...}\" or v)\n            if (settings.displayTable and valueIsTable and (depth <= settings.maxDepth)) then\n                local svgtable, ret = svg.toSVG(v, x, (ystart + (i + ii)*(svg._fontsize + svg._pad)), settings, depth+1)\n                ii = ii + ret\n                svgtext = svgtext .. svgtable\n            end\n        end\n        return svgtext, i + ii\n    end\n\n    function svg.imageCut(path, imageSize, screenViewbox, svgViewbox) -- viewbox are rect: x y width height\n        return string.format([[\n            <svg x=\"%d\" y=\"%d\" width=\"%d\" height=\"%d\" preserveAspectRatio=\"none\"\n            viewBox=\"%d %d %d %d\"\n            xmlns=\"http://www.w3.org/2000/svg\" \n            xmlns:xlink=\"http://www.w3.org/1999/xlink\"> \n            <image width=\"%d\" height=\"%d\" xlink:href=\"%s\" />\n            </svg>]],\n            screenViewbox.x, screenViewbox.y, screenViewbox.width, screenViewbox.height,\n            svgViewbox.x, svgViewbox.y, svgViewbox.width, svgViewbox.height,\n            imageSize.width, imageSize.height, path)\n    end\n\n    svg.header = [[\n    <svg class=\"svg\"\n    width=\"1920\" height=\"1080\"\n    viewBox=\"0 0 1920 1080\"\n    xmlns=\"http://www.w3.org/2000/svg\" \n    xmlns:xlink=\"http://www.w3.org/1999/xlink\"> \n    <style>\n    .svg {\n    position:absolute;\n    left: 0;\n    top: 0;\n    height: 100vh;\n    width: 100vw;\n    }\n    ]]\n    svg.style = [[]]\n    svg.base = [[]]\n    svg.footer = [[</svg>]]\n    svg.body = [[]]\n\n    return svg\nend","filter":{"args":[],"signature":"start()","slotKey":"-3"},"key":"6"},{"code":"-- Button ButtonGroup VirtualCursor\n-- v1.2\n\nfunction doNothing() end\n\nfunction requireButton()\n    -- Button\n    local Button = {}\n    Button.__index = Button\n    Button.color = \"white\"\n\n    --636363 99ccff\n    function\tButton:updateSvghelper(svgh)\n        svgh.style = svgh.style .. string.format([[\n            .button-rect-default { stroke-width:1; stroke:%s; fill:none; }\n            .button-rect-hovered { stroke-width:1; stroke:%s; fill:%s; }\n            .button-rect-selected { stroke-width:1; stroke:%s; fill:%s; }\n            .button-text-default { fill:%s; font-weight:bold; }\n            .button-text-hovered { fill:%s; font-weight:bold; }\n            .button-text-selected { fill:%s; font-weight:bold; }]],\n            self.color,\n            \"#5588ff\", \"#5588ff\",\n            self.color, self.color,\n            self.color,\n            \"black\",\n            \"black\")\n    end\n\n    function\tButton.updateButtonsStates(buttons, cursorPos)\n        if buttons == nil then\n            return false\n        end\n        local changes = false\n        for _, b in pairs(buttons) do\n            local c = b:updateState(cursorPos)\n            if not changes then\n                changes = c\n            end\n        end\n        return changes\n    end\n    function\tButton:updateState(cursorPos)\n        if self.active then\n            -- system.print(\"Button.updateButtonsStates : \" .. b.text)\n            local rect = {\n                x = self.pos.x,\n                y = self.pos.y,\n                width = self.size.width,\n                height = self.size.height\n            }\n            local oldhover = self.hovered\n            self.hovered = isWithinRect(rect, cursorPos)\n            if self.hovered then self.onHover(self) end\n            if oldhover ~= self.hovered then\n                return true\n            end\n        end\n        return false\n    end\n\n    function    Button.tryClickOnButtons(buttons, cursorPos)\n        if buttons == nil then\n            return false\n        end\n        local clicked = false\n        for _, b in pairs(buttons) do\n            local c = b:tryClick(cursorPos)\n            if not clicked then\n                clicked = c\n            end\n        end\n        return clicked\n    end\n    function    Button:tryClick(cursorPos)\n        --could only check if hovered, but it's not correct (a button could have the state hovered without being actually hovered)\n        if self.active then\n            local rect = {\n                x = self.pos.x,\n                y = self.pos.y,\n                width = self.size.width,\n                height = self.size.height\n            }\n            if isWithinRect(rect, cursorPos) then\n                self:_click()\n                return true\n            end\n        end\n        return false\n    end\n\n\n    function Button.new(text, pos, size, fontsize)\n        local b = {\n            pos = vec3(pos),\n            size = {width=size.width,height=size.height},\n            fontsize = fontsize or 15,\n            active = true,\n            hovered = false, -- need bitmask\n            selected = false, -- need bitmask\n            canToggle = false,\n            buttonGroup = nil, -- a reference for buttons where only one can be selected at a time (later: several while holding shift)\n            text = text,\n            onHover = doNothing, -- a user defined func\n            onClick = doNothing, -- a user defined func\n        }\n        b = setmetatable(b, Button)\n        return b\n    end\n    \n    function Button:_click()\n        --system.print(\"_click \" .. self.text)\n        if self.canToggle then\n            self:toggle()\n        end\n        self.onClick(self)\n    end\n\n    function Button:toggle()\n        self.selected = not self.selected\n        if self.buttonGroup then\n            self.buttonGroup:clearSelected() -- if shift is not down\n            if self.selected then \n                self.buttonGroup:addSelected(self)\n            end\n        end\n    end\n    \n    function Button:draw(newpos, flags)\n        flags = flags or {}\n        self.pos = newpos and vec3(newpos) or self.pos\n        --reduce class name len?\n        local rectclass = \"button-rect-default\"\n        if self.selected then rectclass = \"button-rect-selected\"\n        elseif self.hovered then rectclass = \"button-rect-hovered\" end\n        local textclass = \"button-text-default\"\n        if self.selected then textclass = \"button-text-selected\"\n        elseif self.hovered then textclass = \"button-text-hovered\" end\n        local textposY = math.floor(self.pos.y + self.fontsize + 0.35*(self.size.height-self.fontsize))\n        local round = math.floor(self.fontsize*0.4)\n        local svgcode = \"\"\n\n        if self.hovered or self.selected or flags.drawBorder ~= false then\n            svgcode = svgcode .. string.format([[\n                <rect x=\"%d\" y=\"%d\" width=\"%d\" height=\"%d\" rx=\"%d\" ry=\"%d\" class=\"%s\" />]],\n                self.pos.x, self.pos.y, self.size.width, self.size.height, round, round, rectclass)\n        end\n        if self.text ~= \"\" then\n            svgcode = svgcode .. string.format([[\n                [[<text x=\"%d\" y=\"%d\" font-size=\"%d\" class=\"%s\">%s</text>]],\n                self.pos.x+5, textposY, self.fontsize, textclass, self.text)\n        end\n        return svgcode\n    end\n\n    -- ButtonGroup\n    local ButtonGroup = {}\n    ButtonGroup.__index = ButtonGroup\n    function ButtonGroup.new()\n        local bg = {\n            selected = {},\n        }\n        bg = setmetatable(bg, ButtonGroup)\n        return bg\n    end\n\n    function ButtonGroup:add(b) table.insert(self, b) end\n    function ButtonGroup:remove(b) table.remove(self, b) end\n\n    function ButtonGroup:clearSelected()\n        for i, button in ipairs(self.selected) do\n            button.selected = false\n            self.selected[i] = nil\n        end\n    end\n\n    function ButtonGroup:addSelected(b)\n        table.insert(self.selected, b)\n        --b.selected = true -- force selected button\n    end\n\n    function ButtonGroup:iter(imin, imax, f)\n        for i, b in ipairs(self) do\n            if i >= imin and i <= imax then\n                f(b)\n            end\n        end\n    end\n\n    --Vcursor\n    local VirtualCursor = {}\n    VirtualCursor.__index = VirtualCursor\n    VirtualCursor.pos = {x=1920/2, y=1080/2}\n    VirtualCursor.old = {x=1920/2, y=1080/2}\n\n    --deprecated, use Button.updateButtonsStates(buttons, cursorPos)\n    function\tVirtualCursor:updateButtonsStates(buttons)\n        if buttons == nil then\n            return false\n        end\n        local changes = false\n        for _, b in pairs(buttons) do\n            if b.active then\n                -- system.print(\"updateButtonsStates : \" .. b.text)\n                local rect = {\n                    x = b.pos.x,\n                    y = b.pos.y,\n                    width = b.size.width,\n                    height = b.size.height\n                }\n                local oldhover = b.hovered\n                b.hovered = isWithinRect(rect, self.pos)\n                if b.hovered then b.onHover(b) end\n                if oldhover ~= b.hovered then changes = true end\n            end\n        end\n        return changes\n    end\n    --deprecated, use Button.tryClickOnButtons(buttons, cursorPos)\n    function\tVirtualCursor:tryClickOn(buttons)\n        if buttons == nil then\n            system.print(\"tryClickOn nil buttons\")\n            return false\n        end\n        local clicked = false\n        for _, b in pairs(buttons) do\n            if b.active then\n                if b.hovered then\n                    b:_click()\n                    clicked = true\n                end\n            end\n        end\n        return clicked\n    end\n\n    return setmetatable(Button, {\n            __call = function(_, ...) return Button.new(...) end\n        }),\n        setmetatable(ButtonGroup, {\n            __call = function(_, ...) return ButtonGroup.new(...) end\n        }),\n        VirtualCursor\nend\n\n","filter":{"args":[],"signature":"start()","slotKey":"-3"},"key":"7"},{"code":"--[[\n    Safe Travel Infos v1.3\n\n    links order:\n        1. core\n        2. screen\n\n    warning: this does not handle the safe zone\n\n    dep:\n        svghelper\n        Basic Travel Infos\n]]\n\nlocal function round(num, numDecimalPlaces)\n    local mult = 10^(numDecimalPlaces or 0)\n    return math.floor(num * mult + 0.5) / mult\nend\n\nlocal image_links = {\n    Generic_Moon = \"assets.prod.novaquark.com/20368/f410e727-9d4d-4eab-98bf-22994b3fbdcf.png\",\n    Sun = \"assets.prod.novaquark.com/20368/0936494e-9b3d-4d60-9ea0-d93a3f3e29cd.png\",\n    Alioth = \"assets.prod.novaquark.com/20368/954f3adb-3369-4ea9-854d-a14606334152.png\",\n    Alioth_bis = \"assets.prod.novaquark.com/20368/b83225ed-fb96-404c-8c91-86ac15dfbbec.png\",\n    Sanctuary = \"assets.prod.novaquark.com/20368/1a70dbff-24bc-44cb-905c-6d375d9613b8.png\",\n    Feli = \"assets.prod.novaquark.com/20368/da91066c-b3fd-41f4-8c01-26131b0a7841.png\",\n    Ion = \"assets.prod.novaquark.com/20368/91d10712-dc51-4b73-9fc0-6f07d96605a6.png\",\n    Madis = \"assets.prod.novaquark.com/20368/46d57ef4-40ee-46ca-8cc5-5aee1504bbfe.png\",\n    Jago = \"assets.prod.novaquark.com/20368/7fca8389-6b70-4198-a9c3-4875d15edb38.png\",\n    Lacobus = \"assets.prod.novaquark.com/20368/cb67a6a4-933c-4688-a637-898c89eb5b94.png\",\n    Sicari = \"assets.prod.novaquark.com/20368/f6e2f801-075f-4ccd-ab94-46d060517e8f.png\",\n    Sinnen = \"assets.prod.novaquark.com/20368/54a99084-7c2b-461b-ab1f-ae4229b3b821.png\",\n    Symeon = \"assets.prod.novaquark.com/20368/97940324-f194-4e03-808d-d71733ad545a.png\",\n    Talemai = \"assets.prod.novaquark.com/20368/f68628d9-3245-4d76-968e-ad9c63a19c19.png\",\n    Teoma = \"assets.prod.novaquark.com/20368/5a01dd8c-3cf8-4151-99a2-83b22f1e7249.png\",\n    Thades = \"assets.prod.novaquark.com/20368/59f997a2-bcca-45cf-aa35-26e0e41ed5c1.png\",\n}\nlocal su = 200000\n\nfunction    requireSafeTravelInfos()\n    local sti = {}\n    --[[\n        todo:\n        calculate all heights for all routes, 12*11 too many? display only top 10?\n        calculate the safe zone bubble\n            need 4 points?\n        detect if parabol trajectory is in the middle of another travel route\n            give the best parabol route depending of the angle, with a set desto point\n    ]]\n    sti.color = \"white\"\n    sti.dangerZonesHeights = {\n        2*su, -- the detection range of a space radar, 100% sure to be caught by a scout warping\n        4*su, -- an arbitrary margin\n        6*su, -- another one \n    }\n    sti.dangerZoneScreenHeight = 250 --px\n    sti.dangerZonesColors = {\"#ff4d4d\", \"#ff8533\", \"#ffff66\"}\n    sti.planetaryProtection = 2.5*su\n    sti.safeRouteAngle = 20 --degree\n    sti.bti = nil\n    sti.origin = 1\n    sti.destination = 2\n    --[[\n        1 Alioth\n        2 Madis\n        3 Thades\n        4 Talemai\n        5 Feli\n        6 Sicari\n        7 Sinnen\n        8 Teoma\n        9 Jago\n        10 Symeon\n        11 Ion\n        12 Lacobus\n    ]]\n\n\n    function    sti:setTextColor(color)\n        if type(color) == \"string\" then\n            self.color = color\n            self.bti.color = color\n        else\n            system.print(\"Error: wrong type for argument #1 of sti:setTextColor(color), string required\")\n        end\n    end\n\n    function    sti:initBti(bti)\n        self.bti = bti\n        for k, v in pairs(self.bti.waypoints) do\n            v.image = image_links[v.name]\n        end\n    end\n\n    function    sti:updateSvghelper(svgh)\n        svgh.base = svgh.base .. string.format([[\n            <linearGradient  id=\"danger\" x1=\"0%%\" x2=\"0%%\" y1=\"0%%\" y2=\"100%%\">\n            <stop offset=\"5%%\" stop-color=\"none\" stop-opacity=\"1\"/>\n            <stop offset=\"10%%\" stop-color=\"%s\" stop-opacity=\"1\"/>\n            <stop offset=\"30%%\" stop-color=\"%s\" stop-opacity=\"1\"/>\n            <stop offset=\"40%%\" stop-color=\"%s\" stop-opacity=\"1\"/>\n            <stop offset=\"60%%\" stop-color=\"%s\" stop-opacity=\"1\"/>\n            <stop offset=\"70%%\" stop-color=\"%s\" stop-opacity=\"1\"/>\n            <stop offset=\"90%%\" stop-color=\"%s\" stop-opacity=\"1\"/>\n            <stop offset=\"95%%\" stop-color=\"none\" stop-opacity=\"1\"/>\n            <stop offset=\"100%%\" stop-color=\"none\" stop-opacity=\"1\" />\n            </linearGradient>]],\n            self.dangerZonesColors[3],\n            self.dangerZonesColors[2],\n            self.dangerZonesColors[1],\n            self.dangerZonesColors[1],\n            self.dangerZonesColors[2],\n            self.dangerZonesColors[3])\n        svgh.base = svgh.base .. string.format([[\n            <linearGradient  id=\"half-danger\" x1=\"0%%\" x2=\"0%%\" y1=\"0%%\" y2=\"100%%\">\n            <stop offset=\"10%%\" stop-color=\"none\" stop-opacity=\"1\"/>\n            <stop offset=\"20%%\" stop-color=\"%s\" stop-opacity=\"1\"/>\n            <stop offset=\"70%%\" stop-color=\"%s\" stop-opacity=\"1\"/>\n            <stop offset=\"90%%\" stop-color=\"%s\" stop-opacity=\"1\"/>\n            <stop offset=\"100%%\" stop-color=\"%s\" stop-opacity=\"1\"/>\n            </linearGradient>]],\n            self.dangerZonesColors[3],\n            self.dangerZonesColors[2],\n            self.dangerZonesColors[1],\n            self.dangerZonesColors[1])\n        svgh.base = svgh.base .. string.format([[\n            <linearGradient  id=\"black-topdown\" x1=\"0%%\" x2=\"0%%\" y1=\"0%%\" y2=\"100%%\">\n            <stop offset=\"0%%\" stop-color=\"none\" stop-opacity=\"1\"/>\n            <stop offset=\"80%%\" stop-color=\"%s\" stop-opacity=\"1\"/>\n            <stop offset=\"100%%\" stop-color=\"none\" stop-opacity=\"0\" />\n            </linearGradient>]], \"none\")\n        svgh.base = svgh.base .. string.format([[\n            <linearGradient  id=\"black-leftright\" x1=\"0%%\" x2=\"100%%\" y1=\"0%%\" y2=\"0%%\">\n            <stop offset=\"0%%\" stop-color=\"none\" stop-opacity=\"1\"/>\n            <stop offset=\"15%%\" stop-color=\"%s\" stop-opacity=\"1\"/>\n            <stop offset=\"100%%\" stop-color=\"none\" stop-opacity=\"0.35\" />\n            </linearGradient>]], \"none\")\n        svgh.base = svgh.base .. string.format([[\n            <linearGradient  id=\"black-rightleft\" x1=\"100%%\" x2=\"0%%\" y1=\"0%%\" y2=\"0%%\">\n            <stop offset=\"0%%\" stop-color=\"none\" stop-opacity=\"1\"/>\n            <stop offset=\"15%%\" stop-color=\"%s\" stop-opacity=\"1\"/>\n            <stop offset=\"100%%\" stop-color=\"none\" stop-opacity=\"0.35\" />\n            </linearGradient>]], \"none\")\n    end\n\n\n    function    sti:getSvgDangerZones(ypos)\n        local svgcode = \"\"\n        --gradient zones\n        svgcode = svgcode .. string.format([[\n            <rect x=\"0\" y=\"%d\" width=\"%d\" height=\"%d\" fill=\"url(#danger)\" />\n            ]], ypos-self.dangerZoneScreenHeight, g.w, self.dangerZoneScreenHeight*2)\n        --base route (flashy red)\n        svgcode = svgcode .. string.format([[\n            <line x1=\"0\" y1=\"%d\" x2=\"%s\" y2=\"%d\" stroke=\"#cc0000\" stroke-width=\"7\" />\n            ]], ypos, g.w, ypos)\n        --warp tunnel\n        svgcode = svgcode .. string.format([[\n            <text x=\"%d\" y=\"%d\" font-size=\"%d\" fill=\"#660000\" text-anchor=\"middle\">warp tunnel</text>\n            ]], g.w/2, ypos+25, 20)\n        return svgcode\n    end\n    function    sti:getSvgPlanetZones(ypos)\n        local svgcode = \"\"\n        local planetsize = {width=300, height=300}\n        local offsetX = 100\n        \n        --planetary protection\n        svgcode = svgcode .. string.format([[\n            <circle cx=\"%d\" cy=\"%d\" r=\"%d\" fill=\"black\" />\n            <circle cx=\"%d\" cy=\"%d\" r=\"%d\" fill=\"black\" />\n        ]], offsetX, math.floor(ypos),  math.floor(planetsize.width),\n            g.w-offsetX, math.floor(ypos),  math.floor(planetsize.width))\n\n        --image\n        if true then\n            local pcoef = 1.35\n            local imageSize = {width=512,height=512}\n            local svgViewbox = {x=0, y=0, width=512, height=512}\n            local originViewbox = {}\n            local destinationViewbox = {}\n            local c = (sti.origin == 3 and 2 or 1) * pcoef\n            originViewbox.x = math.floor(0+offsetX-planetsize.width/2 * c)\n            originViewbox.y = math.floor(ypos-planetsize.height/2 * c)\n            originViewbox.width = planetsize.width * c\n            originViewbox.height = planetsize.height * c\n            c = (sti.destination == 3 and 2 or 1) * pcoef\n            destinationViewbox.x = math.floor(g.w-offsetX-planetsize.width/2 * c)\n            destinationViewbox.y = math.floor(ypos-planetsize.height/2 * c)\n            destinationViewbox.width = planetsize.width * c\n            destinationViewbox.height = planetsize.height * c\n\n            svgcode = svgcode .. svg.imageCut(self.bti.waypoints[self.origin].image, imageSize, originViewbox, svgViewbox)\n            svgcode = svgcode .. svg.imageCut(self.bti.waypoints[self.destination].image, imageSize, destinationViewbox, svgViewbox)\n        else -- or simple circle\n            svgcode = svgcode .. string.format([[\n                <circle cx=\"%d\" cy=\"%d\" r=\"%d\" fill=\"%s\" />\n                <circle cx=\"%d\" cy=\"%d\" r=\"%d\" fill=\"%s\" />\n            ]], offsetX, math.floor(ypos),  math.floor(planetsize.width/2), \"#734d26\",\n                g.w-offsetX, math.floor(ypos),  math.floor(planetsize.width/2), \"#734d26\")\n        end\n\n        local pvpOrigin = offsetX + planetsize.width\n        local pvpDestination = g.w - offsetX - planetsize.width\n        return svgcode, pvpOrigin, pvpDestination\n    end\n    function    sti:getSvgDangerZoneForDirectTrajectory(shipHeight, shipPos, destination)\n        local svgcode = \"\"\n        local dangerDist = vec3(destination - shipPos):len()\n        if shipHeight > self.dangerZonesHeights[1] then\n            dangerDist = dangerDist * self.dangerZonesHeights[1] / shipHeight -- thales\n        end\n        dangerDist = math.max(0, dangerDist / su - 2.5)\n        local screenPos = vec3(300, 980, 0)\n        svgcode = svgcode .. string.format([[\n            <line x1=\"%d\" y1=\"%d\" x2=\"%d\" y2=\"%d\" stroke=\"darkgray\" stroke-width=\"6\" stroke-dasharray=\"12\" />\n            <text x=\"%d\" y=\"%d\" font-size=\"50\" fill=\"%s\">Direct trajectory, %s su in danger zone</text>\n            <g font-size=\"50\" fill=\"%s\">\n            <text x=\"%d\" y=\"%d\">Direct trajectory, %s su in</text></g>]],\n            screenPos.x, screenPos.y-17, screenPos.x + 90, screenPos.y-17,\n            screenPos.x + 110, screenPos.y, self.dangerZonesColors[1], round(dangerDist, 2),\n            self.color,\n            screenPos.x + 110, screenPos.y, round(dangerDist, 2))\n\n        return svgcode\n    end\n    function    sti:getSvgShip(ypos, x1, x2)\n        local svgcode = \"\"\n\n        local origin = vec3(self.bti.waypoints[self.origin])\n        local destination = vec3(self.bti.waypoints[self.destination])\n        local travel = destination - origin\n        local shipPos = vec3(core.getConstructWorldPos())\n        local floorVec = (shipPos - origin):project_on(travel)\n        local percent = floorVec:len() / travel:len()\n        local floorPos = origin + floorVec\n        local shipHeight = (shipPos - floorPos):len()\n        --[[\n            debug.origin = self.bti.waypoints[self.origin].name\n            debug.destination = self.bti.waypoints[self.destination].name\n            debug.percent = percent\n            debug.shipHeight = shipHeight\n        ]]\n\n        local xfloor = math.floor(x1 + percent * (x2 - x1))\n        local yship = math.floor(self.dangerZoneScreenHeight * shipHeight / self.dangerZonesHeights[3])\n        --yship = math.min(yship, 350)\n        local ySu = math.min(yship, 350)\n\n        svgcode = svgcode .. string.format([[\n            <line x1=\"%d\" y1=\"%d\" x2=\"%d\" y2=\"%d\" stroke=\"darkgray\" stroke-width=\"3\" />\n            <line x1=\"%d\" y1=\"%d\" x2=\"%d\" y2=\"%d\" stroke=\"darkgray\" stroke-width=\"6\" stroke-dasharray=\"12\" />\n            <circle cx=\"%d\" cy=\"%d\" r=\"12\" fill=\"black\" stroke=\"white\" stroke-width=4 />\n            <text x=\"%d\" y=\"%d\" font-size=\"50\" fill=\"white\" stroke=\"black\" stroke-width=\"20\" text-anchor=\"end\">%s</text>]],\n            xfloor, ypos, xfloor, ypos-yship,\n            xfloor, ypos-yship, x2, ypos,\n            xfloor, ypos-yship,\n            xfloor-30, ypos-ySu+30, (round(shipHeight/su, 2)..\" su ↥\"))\n\n        --danger zone if going right to desto\n        svgcode = svgcode .. self:getSvgDangerZoneForDirectTrajectory(shipHeight, shipPos, destination)\n        return svgcode\n    end\n\n    function    sti:getSvgBti(pos)\n        local svgcode = \"\"\n        svgcode = svgcode .. string.format([[\n            <rect x=\"%d\" y=\"%d\" width=\"%d\" height=\"%d\" stroke=\"none\" fill=\"%s\" stroke-width=\"3\" stroke-dasharray=\"4\"/>]],\n            0, 0, g.w, 350, \"url(#black-topdown)\")\n        svgcode = svgcode .. self.bti:getSvgcode(pos, self.bti.waypoints[self.destination])\n        return svgcode\n    end\n\n    function    sti:getSvgcode()\n        local svgcode = \"\"\n        local ypos = math.floor(g.h*0.60)\n        svgcode = svgcode .. self:getSvgDangerZones(ypos)\n        local svgtmp, x1, x2 = self:getSvgPlanetZones(ypos)\n        svgcode = svgcode .. svgtmp\n        svgcode = svgcode .. self:getSvgShip(ypos, x1, x2)\n        svgcode = svgcode .. self:getSvgBti(vec3(30, 75, 0))\n\n        return svgcode\n    end\n\n    function    sti:calculateAllHeights()\n        local shipPos = vec3(core.getConstructWorldPos())\n        local heights = {} -- array of array for 2d matrice halved (x:y = y:x and x=y is impossible)\n        for j, body in ipairs(self.bti.waypoints) do\n            heights[i] = {}\n            local origin = vec3(body)\n            for i, body in ipairs(self.bti.waypoints) do\n                if (i ~= j) then\n                    local destination = vec3(self.bti.waypoints[i])\n                    local travel = destination - origin\n                    local floorVec = (shipPos - origin):project_on(travel)\n                    local floorPos = origin + floorVec\n                    local shipHeight = (shipPos - floorPos):len()\n                    heights[j][i] = shipHeight\n                end\n            end\n        end\n    end\n\n    return sti\nend\n\nfunction    requirePlanetSelector()\n    local ps = {}\n    ps.color = \"darkgray\"\n    ps.y = 325\n    ps.fontsize = 45\n    ps.indent = 10\n    \n    ps.cursorPos = {x=0,y=0}\n    ps.buttons = {}\n    ps.planetSelectionOrigin = ButtonGroup()\n    ps.planetSelectionDestination = ButtonGroup()\n    ps._destinationIndexMap = {}\n    ps._originIndexMap = {}\n\n    function    ps:initPlanets(planets)\n        local size = {width=175,height=50}\n        local ftsize = 35\n        for i, v in ipairs(sti.bti.waypoints) do\n            local b1 = Button(v.name, vec3(self.indent,self.y+(size.height+4)*(i-1),0), size, ftsize)\n            b1.buttonGroup = self.planetSelectionOrigin\n            b1.active = true\n            b1.canToggle = true\n            self.planetSelectionOrigin:add(b1)\n            b1.onClick = selectOrigin\n            table.insert(self.buttons, b1)\n            self._originIndexMap[v.name] = i\n\n            local b2 = Button(v.name, vec3(g.w-self.indent-size.width,self.y+(size.height+4)*(i-1),0), size, ftsize)\n            b2.buttonGroup = self.planetSelectionDestination\n            b2.active = true\n            b2.canToggle = true\n            self.planetSelectionDestination:add(b2)\n            b2.onClick = selectDestination\n            table.insert(self.buttons, b2)\n            self._destinationIndexMap[v.name] = i\n        end\n    end\n\n    function    ps:update()\n        local pos = {\n            x = math.floor(screen.getMouseX()*g.w),\n            y = math.floor(screen.getMouseY()*g.h)\n        }\n        if (pos.x ~= self.cursorPos.x) or (pos.y ~= self.cursorPos.y) then\n            self.cursorPos = pos\n            local changes = Button.updateButtonsStates(self.buttons, self.cursorPos)\n            if changes then\n                g.needRefresh = true\n            end\n        end\n    end\n\n    function    ps:getSvgcode()\n        local svgcode = \"\"\n        svgcode = svgcode .. string.format([[\n            <rect x=\"%d\" y=\"%d\" width=\"%d\" height=\"%d\" stroke=\"none\" fill=\"%s\" stroke-width=\"3\" stroke-dasharray=\"4\"/>]],\n            0, self.y, 190, g.h-self.y, \"url(#black-leftright)\")\n        svgcode = svgcode .. string.format([[\n            <rect x=\"%d\" y=\"%d\" width=\"%d\" height=\"%d\" stroke=\"none\" fill=\"%s\" stroke-width=\"3\" stroke-dasharray=\"4\"/>]],\n            g.w-190, self.y, 190, g.h-self.y, \"url(#black-rightleft)\")\n        svgcode = svgcode .. string.format([[\n            <text x=\"%d\" y=\"%d\" font-size=\"%d\" fill=\"%s\" stroke=\"black\" stroke-width=\"10\">%s</text>,\n            <text x=\"%d\" y=\"%d\" font-size=\"%d\" fill=\"%s\" stroke=\"black\" stroke-width=\"10\" text-anchor=\"end\">%s</text>]],\n            self.indent, self.y-self.indent, self.fontsize, self.color, \"Origin:\",\n            g.w-self.indent, self.y-self.indent, self.fontsize, self.color, \"Destination:\")\n        for i, v in ipairs(self.buttons) do\n            svgcode = svgcode .. v:draw()\n        end\n        return svgcode\n    end\n\n    function    ps:tryClick(x, y)\n        Button.tryClickOnButtons(self.buttons, {x=x, y=y})\n    end\n\n    return ps\nend\n\n--button funcs\nfunction    selectOrigin()\n    local b = selector.planetSelectionOrigin.selected[1]\n    if b then \n        local i = selector._originIndexMap[b.text]\n        sti.origin = i\n        if sti.destination == sti.origin then\n            local p = sti.origin ~= 1 and 1 or 2\n            selector.planetSelectionDestination[p]:_click()\n        end\n        g.needRefresh = true\n    else -- clicked on the current selection, just reselect it (= always 1 selected)\n        selector.planetSelectionOrigin[sti.origin]:_click()\n    end\nend\nfunction    selectDestination()\n    local b = selector.planetSelectionDestination.selected[1]\n    if b then \n        local i = selector._destinationIndexMap[b.text]\n        sti.destination = i\n        if sti.origin == sti.destination then\n            local p = sti.destination ~= 1 and 1 or 2\n            selector.planetSelectionOrigin[p]:_click()\n        end\n        g.needRefresh = true\n    else -- unselected the current selection, just reselect it (always 1 selected)\n        selector.planetSelectionDestination[sti.destination]:_click()\n    end\nend\n","filter":{"args":[],"signature":"start()","slotKey":"-3"},"key":"8"},{"code":"--[[\n    BTI v1.3\n    dependency: SvgHelper\n    \n    unit > start\n        svg = requireSvgHelper() -- or require(\"svghelper\")\n        bti = requireBasicTravelInfos()\n        system.showScreen(1)\n        unit.setTimer(\"eta\", 0.25)\n    unit > tick(eta)\n        svg.body = bti:getSvgcode()\n        system.setScreen(svg.dump())\n    system > actionStart(lshift)\n        bti.target = (bti.target - 1 + bti.maxWaypoints - 1) % bti.maxWaypoints + 1\n    system > actionStart(lalt)\n        bti.target = (bti.target - 1 + bti.maxWaypoints + 1) % bti.maxWaypoints + 1\n\n        todo: add sanctuary\n]]\n\nlocal function dhms(time, displayAll, sep)\n    displayAll = displayAll or false\n    sep = sep or {\"d\",\"h\",\"m\",\"s\"}\n    local dhmsValues = {86400, 3600, 60, 1}\n    local res = \"\"\n    for i, v in ipairs(dhmsValues) do\n        local r = math.floor(time / dhmsValues[i])\n        time = time % dhmsValues[i]\n        if displayAll or r ~= 0 then\n            res = res .. string.format([[%.2d%s]], r, sep[i])\n        end\n    end\n    return res ~= \"\" and res or (\"0\"..sep[4])\nend\n\nfunction requireBasicTravelInfos()\n    local bti = {}\n    bti.waypoints = {\n        {name=\"Alioth\", x=-8, y=-8, z=-126303},\n        {name=\"Madis\", x=17465536, y=22665536, z=-34464},\n        {name=\"Thades\", x=29165536, y=10865536, z=65536},\n        {name=\"Talemai\", x=-13234464, y=55765536, z=465536},\n        {name=\"Feli\", x=-43534464, y=22565536, z=-48934464},\n        {name=\"Sicari\", x=52765536, y=27165538, z=52065535},\n        {name=\"Sinnen\", x=58665538, y=29665535, z=58165535},\n        {name=\"Teoma\", x=80865538, y=54665536, z=-934463},\n        {name=\"Jago\", x=-94134462, y=12765534, z=-3634464},\n        {name=\"Symeon\", x=14165536, y=-85634465, z=-934464},\n        {name=\"Ion\", x=2865536, y=-99034464, z=-934462},\n        {name=\"Lacobus\", x=98865536, y=13534464, z=-934461.990}\n    }\n    bti.maxWaypoints = 0\n    for _, v in ipairs(bti.waypoints) do\n        bti.maxWaypoints = bti.maxWaypoints + 1\n    end\n    bti.target = 1\n    bti.color = \"#99ccff\"\n    bti.fontsize = 18\n\n    function\tbti:travelInfos(target, shipPos, speed, mass, pos, fontsize)\n        fontsize = fontsize or self.fontsize\n        pos = pos and pos or vec3(10, 30, 0)\n        local name = target.name or \"?\"\n        local dist = (shipPos - target):len()\n        local su = 200000\n        local t = 1000\n\n        local travel = {\n            atCurrentSpeed = math.floor(dist / speed),\n            atMaxSpeed = math.floor(dist / 8333),\n            warpCells = ((mass/t) * (dist/su) * 0.00024)\n        }\n\n        fontsize = fontsize or 20\n        local x = pos.x\n        local y = pos.y\n        local svgcode = string.format([[<g fill=\"%s\" font-size=\"%dpx\">]], self.color, fontsize)\n        --title\n        svgcode = svgcode .. string.format([[\n            <text x=\"%d\" y=\"%d\" font-weight=\"bold\" text-decoration=\"underline\">Travel time to %s (%dsu) :</text>]],\n            x, y, name, math.ceil(dist/su))\n        --current speed\n        y = y + fontsize\n        svgcode = svgcode .. string.format([[\n            <text x=\"%d\" y=\"%d\">At current speed: %s</text>]],\n            x, y, travel.atCurrentSpeed == 1/0 and \"∞\" or dhms(travel.atCurrentSpeed))\n        --max speed\n        y = y + fontsize\n        svgcode = svgcode .. string.format([[\n            <text x=\"%d\" y=\"%d\">At max speed: %s</text>]],\n            x, y, dhms(travel.atMaxSpeed))\n        --warp cell\n        y = y + fontsize\n        svgcode = svgcode .. string.format([[\n            <text x=\"%d\" y=\"%d\">Warp cells for %dt : %s</text>]],\n            x, y, math.ceil(mass/t), math.ceil(travel.warpCells))\n\n        svgcode = svgcode .. [[</g>]]\n        return svgcode\n    end\n    \n    function\tbti:getSvgcode(pos, target) -- target is a vec3 with a \"name\" key\n        local speed = vec3(core.getWorldVelocity()):len()\n        local selectedTarget = target and target or self.waypoints[self.target]\n        local shipPos = vec3(core.getConstructWorldPos())\n        local mass = core.getConstructMass()\n\n        return self:travelInfos(selectedTarget, shipPos, speed, mass, pos, self.fontsize)\n    end\n    \n    return bti\nend","filter":{"args":[],"signature":"start()","slotKey":"-3"},"key":"9"},{"code":"function requireRect()\n    local rect = {}\n    rect.__index = rect\n\n    function rect.new(x, y, width, height)\n        -- allow construction via (a, b, c, d), { a, b, c, d } or { x = a, y = b, width = c, height = d }\n        if type(x) == \"table\" then\n            return setmetatable({\n                    x = x.x or x[1] or 0,\n                    y = x.y or x[2] or 0,\n                    width = x.width or x[3] or 0,\n                    height = x.height or x[4] or 0,\n                }, rect)\n        else\n            return setmetatable({\n                    x = x or 0,\n                    y = y or 0,\n                    width = width or 0,\n                    height = height or 0,\n                }, rect)\n        end\n    end\n    return setmetatable( rect, {\n            __call = function(_, ...) return rect.new(...) end\n        })\nend\n\nfunction isBetween(min, max, value)\n    return min <= value and max >= value\nend\nfunction isWithinRect(rect, pos)--Rect.isPosWithin(pos) -- Rect.contains(pos)\n    return isBetween(rect.x, rect.x+rect.width, pos.x) and isBetween(rect.y, rect.y+rect.height, pos.y)\nend","filter":{"args":[],"signature":"start()","slotKey":"-3"},"key":"10"}],"methods":[],"events":[]}
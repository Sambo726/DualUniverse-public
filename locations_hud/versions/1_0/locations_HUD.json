{"slots":{"0":{"name":"gyro","type":{"events":[],"methods":[]}},"1":{"name":"core","type":{"events":[],"methods":[]}},"2":{"name":"slot3","type":{"events":[],"methods":[]}},"3":{"name":"slot4","type":{"events":[],"methods":[]}},"4":{"name":"slot5","type":{"events":[],"methods":[]}},"5":{"name":"slot6","type":{"events":[],"methods":[]}},"6":{"name":"slot7","type":{"events":[],"methods":[]}},"7":{"name":"slot8","type":{"events":[],"methods":[]}},"8":{"name":"slot9","type":{"events":[],"methods":[]}},"9":{"name":"slot10","type":{"events":[],"methods":[]}},"-1":{"name":"unit","type":{"events":[],"methods":[]}},"-2":{"name":"system","type":{"events":[],"methods":[]}},"-3":{"name":"library","type":{"events":[],"methods":[]}}},"handlers":[{"code":"--[[\nAuthor: Ater Omen\nWORK IN PROGRESS\n03 Sept 2020\n\nThere is no dependency as it uses only vec3,\nbut it is recommended to use JayleBreak's pos convertor: planetref.lua and atlas.lua \n\nThis HUD works only with a fov of 90Â°, with locked camera,\nthere will be maybe a free camera mode later but for now we miss infos from user inputs.\nSince system.lockView() is disabled it is not recommanded to use 1st person.\nThe best use for this HUD is in locked 3rd person view when piloting, zoomed out at max range.\nYou can display it on a screen too, see unit>tick(hud)\n\nLua parameters: there are a lot of lua parameters used for calibration,\ntwick them if you know what you are doing.\n\nInstallation process: link a gyroscope to the programming board\n\nCommands:\n\toption 3 : swap between locked 1st person and locked 3rd person\n\toption 9 : toggle hud\n\nKnown bugs:\n\t- some planets data may be wrong, making the locations display at the wrong place\n\t- there might be a performance bug when toggling free mouse (tab), restart to fix it.\n\t- calibrations need to be more precise depending on the ship core size.\n\nUsage (there are examples with the arkship and districts after this doc):\nHow to add new Location from a bookmark:\n\n\t-- create a vec3 from the bookmark\n\tlocal\tspace_station = toWorld(\"::pos{0,0,8000000.0,11000000.0,-50000.0}\")\n\t-- all Locations are in the table Location.planets for now\n\tLocations.planets[\"Space Station\"] = Location(space_station)\n\n\t-- the name of the key will be used when displaying the Location\n\nHow to add a Location within another with the parenting system:\n\t\n\tlocal arkship = toWorld(\"::pos{0,2,29.7656,95.4761,3512.4180}\")\n\t-- added in group 2, group 1 is for moons (display with threshold of 5su from the planet)\n\tLocations.planets.Alioth:add(2, {\n        [\"Arkship\"] = Location(arkship),\n\t}, 1 * su) -- it will be displayed below that distance from the parent (here Alioth)\n\n\t-- change distance threshold of the group 2 of Alioth:\n\tLocations.planets.Alioth:setGroupThreshold(2, 200 * su)\n\nHow to customize the HUD:\n\n\t-- it will affect all children of the Location\n\tLocations.planets.Alioth[2].Arkship.params = {\n\t\tcolor = \"cyan\",\n\t\tmode = g_keepOnBorders,\n\t\tblinking = true\n\t}\n\t-- if you want, you can also edit directly the svg lines in the library functions\n]]\n\nlocal loc = require \"Locations\"\nlocal PlanetaryReference = require \"planetref\"\nlocal referenceTableSource = require \"atlas\"\nlocal galaxyReference = PlanetaryReference(referenceTableSource)\nlocal helios = galaxyReference:getPlanetarySystem(0)\nassert(helios, \"helios nil\")\nassert(Locations.planets, \"Locations.planets is nil\")\nfunction toWorld(pos)\n    local body, world = helios:convertToBodyIdAndWorldCoordinates(pos)\n    return world\nend\nfunction toWorld2(pos) -- backup, not used\n    local mappos = galaxyReference.MapPosition(pos)\n    if mappos.bodyId == 0 then\n        return vec3(mappos.latitude, mappos.longitude, mappos.altitude)\n    end\n    local body = helios:getBodyParameters(mappos)\n    local worldpos = body:convertToWorldCoordinates(mappos)\n    return worldpos\nend\n\nlocal su = 200000\ng_keepOnBorders = 1 -- for clarity\ndeg2rad = math.pi/180\nrad2deg = 180/math.pi\n\n----------------------------------------------------\n-- additional location declarations\n----------------------------------------------------\nlocal arkship = toWorld(\"::pos{0,2,29.7656,95.4761,3512.4180}\")\nlocal d1 = toWorld(\"::pos{0,2,31.2004,101.4092,256.8846}\")\nlocal d2 = toWorld(\"::pos{0,2,24.6040,89.0818,419.8167}\")\nlocal d3 = toWorld(\"::pos{0,2,35.5824,89.1240,197.8451}\")\nlocal d4 = toWorld(\"::pos{0,2,35.5824,89.1240,197.8451}\")\nlocal d5 = toWorld(\"::pos{0,2,32.3569,86.7947,386.5552}\")\nlocal d6 = toWorld(\"::pos{0,2,35.7309,102.2480,198.6081}\")\nlocal d7 = toWorld(\"::pos{0,2,22.1719,99.3007,212.0475}\")\nlocal d8 = toWorld(\"::pos{0,2,21.3646,95.3442,336.1729}\")\nlocal d9 = toWorld(\"::pos{0,2,28.8496,86.8964,271.0403}\")\nlocal d10 = toWorld(\"::pos{0,2,36.3803,93.0113,193.8580}\")\n\nLocations.planets.Alioth:add(2, {\n        [\"Arkship\"] = Location(arkship),\n}, 1 * su) -- displayed below that distance from the parent (here Alioth)\nLocations.planets.Alioth[2].Arkship.params = {color = \"cyan\", mode = g_keepOnBorders, blinking = true}\nLocations.planets.Alioth[2].Arkship:add(1, {\n        [\"District 1\"] = Location(d1),\n        [\"District 2\"] = Location(d2),\n        [\"District 3\"] = Location(d3),\n        [\"District 4\"] = Location(d4),\n        [\"District 5\"] = Location(d5),\n        [\"District 6\"] = Location(d6),\n        [\"District 7\"] = Location(d7),\n        [\"District 8\"] = Location(d8),\n        [\"District 9\"] = Location(d9),\n        [\"District 10\"] = Location(d10),\n}, 100000)\n--Locations.planets.Alioth:setGroupThreshold(2, 7 * su)\n\n----------------------------------------------------\n-- settings\n----------------------------------------------------\ng_ringRadius = 12\nsvg = {}\nsvg.header = [[\n<style>\n.svg {\n    position:absolute;\n    left: 0;\n    top: 0;\n    height: 100vh;\n    width: 100vw;\n}\n</style>\n<svg class=\"svg\">\n]]\nsvg.base = [[\n<defs>]] .. svgRing(g_ringRadius, g_ringRadius*2/3) .. [[</defs>\n]]\nsvg.footer = [[</svg>]]\nsvg.body = \"\"\n\ng_hud = true\ng_playerID = unit.getMasterPlayerId()\n\nlocal voxel_len = 0.25\nlocal screen_dim = vec3(12*voxel_len, 7*voxel_len, 0) --12x7voxels (res: 1920x1080)\ng_screenRes = {}\ng_screenRes.x = 1920\ng_screenRes.y = 1080\ng_screenPixelLen = screen_dim.x / g_screenRes.x\ng_screenCenter = vec3(g_screenRes.x/2, g_screenRes.y/2, 0)\ng_screenDist = 7.08 --export --may need a calibration (default 7.08)\ng_screenDist = g_screenDist*voxel_len\ng_screenXCorrection = 0 --export --pixels\ng_screenYCorrection = 0 --export --pixels\n\ng_3rdPersonZCorrection = -20 --export --meters (cam distance behind player)\ng_3rdPersonYCorrection = 4 --export --meters (cam height above player)\ng_3rdPersonActivated = false --export\ng_3rdpersonAngleCorrection = 19.5 --export --camera angle correction depending of the core size\n--[[\ng_3rdpersonAngleCorrection default values for:\n\tcore XS: 18\n\tcore S: 20.0\n\tcore M: ?\n\tcore L: ?\ng_3rdPersonZCorrection default values for:\n\tcore XS: -20\n\tcore S: -40\n\tcore M: ?\n\tcore L: ?\n]]\n\n--text\ng_nameFontSize = 20 --export --pixels\ng_distanceFontSize = 12 --export --pixels\ng_offset = 30 --from icon\ng_opacity = 1.0\n\n--hud\ng_blinking = false --export --global blinking, can be override by params.blinking\ng_blinktime = 2.0 --export --sec\ng_cyclespeed = 2.0 / g_blinktime \ng_refreshRate = 1/60 --export --60 fps\nsystem.showScreen(1)\nsystem.lockView() -- doesn't work yet\nunit.setTimer(\"hud\", g_refreshRate)\n\n\n","filter":{"args":[],"signature":"start()","slotKey":"-1"},"key":"0"},{"code":"--screen content\nsvg.body = \"\"\ndrawTargets(Locations.planets)\n\nsvg.body = svg.body .. [[\n<text x=\"20\" y=\"20\" font-size=\"20px\" fill=\"yellow\">Camera mode: locked ]]..(g_3rdPersonActivated and \"3rd\" or \"1st\")..[[ person</text>\n]]\n\n--[[ debug\nprintVals({\n        g_screenXCorrection = g_screenXCorrection,\n        g_screenYCorrection = g_screenYCorrection,\n        g_3rdPersonZCorrection = g_3rdPersonZCorrection,\n        g_3rdPersonYCorrection = g_3rdPersonYCorrection,\n        g_3rdpersonAngleCorrection = g_3rdpersonAngleCorrection,\n            }, 25, 40)\n\nprintVals({\n        mouseX = system.getMousePosX(),\n        mouseY = system.getMousePosY(),\n}, 250, 250)\n--]]\n\n\n--[[\n\tdisplay on a screen or directly on the HUD\n\tif you want to display on a screen (the item), you must place it right in front of you\n\tand make it fit to the whole screen (your real screen)\n]]\n--screen.setSVG(svg.base .. svg.body)\nsystem.setScreen(svg.header .. svg.base .. svg.body .. svg.footer)\n\n\n","filter":{"args":[{"value":"hud"}],"signature":"tick(timerId)","slotKey":"-1"},"key":"1"},{"code":"g_hud = not g_hud\nif g_hud then\n    system.showScreen(1)\n    unit.setTimer(\"hud\", g_refreshRate)\nelse\n    unit.stopTimer(\"hud\")\n    system.showScreen(0)\nend","filter":{"args":[{"value":"option9"}],"signature":"actionStart(action)","slotKey":"-2"},"key":"2"},{"code":"g_3rdPersonActivated = not g_3rdPersonActivated","filter":{"args":[{"value":"option3"}],"signature":"actionStart(action)","slotKey":"-2"},"key":"3"},{"code":"g_opacity = (g_opacity + (1.0/60.0)*g_cyclespeed) % 2.0\n\n","filter":{"args":[],"signature":"flush()","slotKey":"-2"},"key":"4"},{"code":"function svgRing(outer, inner)\n\t    return string.format([[\n\t        <path id=\"loc\" d=\"m %d %d\n\t        \tA %d %d 0 1 0 %d %d\n\t        \tA %d %d 0 1 0 %d %d Z\n\t             m %d %d\n\t        \tA %d %d 0 1 1 %d %d\n\t        \tA %d %d 0 1 1 %d %d Z\"\n\t         stroke=\"black\" stroke-width=\"0.5\" />\n\t    ]],\n\t        outer, 0,\n\t        outer, outer, outer, outer*2,\n\t        outer, outer, outer, 0,\n\t        0, outer-inner,\n\t        inner, inner, outer, outer+inner,\n\t        inner, inner, outer, outer-inner\n        )\n\tend\nfunction printVals(arr, x, ystart)\n    local fontsize = 15\n    local pad = 3\n    ystart = ystart or 20\n    x = x or 25\n    \n    local i = 0\n    for k, v in pairs(arr) do\n        svg.body = svg.body .. string.format([[\n            <text x=\"%d\" y=\"%d\" font-size=\"%dpx\" fill=\"yellow\" stroke=\"black\" stroke-width=\"2\">%s : %s</text>\n            ]], x, (ystart + i*(fontsize+pad)), fontsize, k, v..\"\")\n        i = i + 1\n    end\nend\n\tfunction roundStr(num, numDecimalPlaces)\n\t\treturn string.format(\"%.\" .. (numDecimalPlaces or 0) .. \"f\", num)\n\tend\nfunction\tdotProduct(a, b)\n\t    return (a.x*b.x + a.y*b.y + a.z*b.z)\n\tend\nfunction clamp(val, min, max)\n    if (val < min) then val = min end\n    if (val > max) then val = max end\n    return val\nend\nfunction\tprojectOnScreen(target, cam, wRight, wUp, wForward)\n    -- target in cam coordinate\n    local target_rel = target - cam\n    local cTarget = vec3(\tdotProduct(target_rel, wRight),\n        \t  \tdotProduct(target_rel, wUp),\n        \t  \tdotProduct(target_rel, wForward)\t)\n\n    -- screen should be perpenicular with wForward and we know its distance\n    -- so we calc the ratio:\n    local ratio = g_screenDist / math.abs(cTarget.z)\n    ratio = ratio * (90/90) --fov WIP \n    -- for the screen coordinates :\n    local coo = vec3(\n\t        (cTarget.x * ratio) / g_screenPixelLen,\n        (-cTarget.y * ratio) / g_screenPixelLen, --negative because screenY has opposite direction of Up\n        (cTarget.z * ratio) / g_screenPixelLen) -- used to know if its behind us\n    return g_screenCenter + coo\nend\nfunction\tdrawTarget(name, coo, distance, params)\n    --display parameters\n    params = params or {}\n    params.color = params.color or \"#a0e838\"\n    params.stroke = params.stroke or \"black\"\n    params.mode = params.mode or 0\n\n    local str = \"\"   \n    if (coo == nil) then return str end\n    if (coo.z < 0 and params.mode ~= g_keepOnBorders) then return str end\n    name = name or \"?\"\n    --display in su/km/m depending on its distance\n    if (distance < 10000) then\n\t        distance = roundStr(distance, 0) .. \" m\"\n    elseif (distance < 200000) then\n\t        distance = roundStr(distance / 1000, 1) .. \" km\"\n    else\n\t        distance = roundStr(distance / 200000, 2) .. \" su\"\n    end\n\n    coo.x = coo.x - g_ringRadius + g_screenXCorrection\n    coo.y = coo.y - g_ringRadius + g_screenYCorrection\n    local cl = {}\n    cl.x = clamp(coo.x, 0, g_screenRes.x - g_ringRadius*2)\n    cl.y = clamp(coo.y, 0, g_screenRes.y - g_ringRadius*2)\n    local onScreen = (cl.x == coo.x and cl.y == coo.y) -- can be behind us!\n    local isBehind = (coo.z < 0)\n    local borderCoo\n\n    local c = coo\n    if (params.mode == g_keepOnBorders and (isBehind or not onScreen)) then\n\t        local pt = vec3(coo.x - g_screenCenter.x, coo.y - g_screenCenter.y, 0)\n\t        local ratio = vec3(g_screenCenter.x / math.abs(pt.x), g_screenCenter.y / math.abs(pt.y), 0)\n\t        local pt_width = pt * ratio.y --intersect with the width\n\t        local pt_height = pt * ratio.x --intersect with the height\n\t        borderCoo = g_screenCenter + ((pt_width:len() < pt_height:len()) and pt_width or pt_height)\n\t        borderCoo.x = clamp(borderCoo.x, 0, g_screenRes.x - g_ringRadius*2)\n\t        borderCoo.y = clamp(borderCoo.y, 0, g_screenRes.y - g_ringRadius*2)\n\t        borderCoo.z = coo.z\n\t        c = borderCoo\n\n\t        if true then --ray debug\n\t            str = str .. string.format([[\n\t            <line x1=\"%f\" y1=\"%f\" x2=\"%f\" y2=\"%f\" style=\"stroke:%s;stroke-width:3\" />\n\t            <line x1=\"%f\" y1=\"%f\" x2=\"%f\" y2=\"%f\" style=\"stroke:%s;stroke-width:1\" />\n\t            ]], g_screenCenter.x, g_screenCenter.y, coo.x, coo.y, params.color,\n\t                coo.x, coo.y, c.x, c.y, params.color)\n        end\n    end\n    local blink = params.blinking or g_blinking\n    local opa = (params.blinking or g_blinking) == true and math.abs(1.0 - g_opacity) or 1.0\n    --[[ debug \n    <use xlink:href=\"#loc\" x=\"%f\" y=\"%f\" fill=\"%s\" fill-opacity=\"%f\"/>\n    <line x1=\"%f\" y1=\"%f\" x2=\"%f\" y2=\"%f\" style=\"stroke:%s;stroke-width:1\" />\n    ]]\n    str = string.format([[\n\t\t<use xlink:href=\"#loc\" x=\"%f\" y=\"%f\" fill=\"%s\" fill-opacity=\"%f\"/>\n        ]], c.x, c.y, params.color, opa,\n    \t\tc.x, c.y, c.x+10, c.y - 10, \"red\")\n    if ((onScreen and not isBehind) or (params.mode ~= g_keepOnBorders and not isBehind)) then \n\t        str = str .. string.format([[\n\t        <text x=\"%f\" y=\"%f\" font-size=\"%fpx\" font-weight=\"bold\" fill-opacity=\"%f\" fill=\"%s\" stroke=\"%s\" stroke-width=\"4\">%s</text>\n\t        <text x=\"%f\" y=\"%f\" font-size=\"%fpx\" font-weight=\"bold\" fill-opacity=\"%f\" fill=\"%s\" stroke=\"%s\" stroke-width=\"3\">%s</text>\n\t    ]],\tc.x+g_offset, c.y+g_offset, g_nameFontSize, 1.0, params.color, params.stroke, name,\n\t        c.x+g_offset, c.y+g_offset+g_distanceFontSize, g_distanceFontSize, 1.0, params.color, params.stroke, distance)\n    end\n\n    if (false and params.mode == g_keepOnBorders) then --ray debug\n\t        str = str .. string.format([[\n\t        <line x1=\"%f\" y1=\"%f\" x2=\"%f\" y2=\"%f\" style=\"stroke:%s;stroke-width:3\" />\n\t        <line x1=\"%f\" y1=\"%f\" x2=\"%f\" y2=\"%f\" style=\"stroke:%s;stroke-width:1\" />\n\t        ]], g_screenCenter.x, g_screenCenter.y, coo.x, coo.y, params.color,\n\t            coo.x, coo.y, c.x, c.y, params.color)\n    end\n    return str\nend\nfunction\tdrawTargets(targets, params)--params is a table with all display parameters\n    local wRight = vec3(gyro.worldRight())\n    local wUp = vec3(gyro.worldUp())\n    local wForward = vec3(gyro.worldForward())\n    local playerpos = vec3(system.getPlayerWorldPos(g_playerID))\n    local campos = playerpos\n\n    if (g_3rdPersonActivated) then --camera correction\n\t        campos = campos + g_3rdPersonZCorrection*wForward + g_3rdPersonYCorrection*wUp\n\t        --to do after cam pos\n\t        local coef = 1 - math.cos(g_3rdpersonAngleCorrection*deg2rad)\n\t        local f = wForward\n\t        local u = wUp\n\t        wForward = (wForward - coef * u):normalize()\n\t        wUp = (wUp + coef * f):normalize()\n    end\n\n    for k, v in pairs(targets) do\n\t        local coo = projectOnScreen(v.pos, campos, wRight, wUp, wForward)\n\t        local dist = (v.pos - playerpos):len() --meters\n\t        local params2 = v.params or params\n\t        svg.body = svg.body .. drawTarget(k, coo, dist, v.params or params)\n\n\t        --children groups\n\t        for i, group in ipairs(v) do\n\t            if (dist < v.childrenThreshold[i]) then\n\t                drawTargets(v[i], params2)\n            \tend\n        \tend\n\n    end\n\nend\n","filter":{"args":[],"signature":"start()","slotKey":"-3"},"key":"5"}],"methods":[],"events":[]}